---
layout: post
title: "Client-server communication peculiarities with GWT and App Engine DataNucleus"
date: 2010-03-12
comments: true
tags: [  GWT, Java, Web dev ]
---

I just had to fight with a strange exception which got raised after a GWT-RPC call to the App Engine back-end server which had the purpose to persistently store an entity into the data store.<br />The exception:<br /><br /><pre class="code">com.google.gwt.user.client.rpc.SerializationException: Type 'org.datanucleus.sco.backed.List' was not assignable to 'com.google.gwt.user.client.rpc.IsSerializable' and did not have a custom field serializer.For security purposes, this type will not be serialized.: instance = []<br /> at com.google.gwt.user.server.rpc.impl.ServerSerializationStreamWriter.serialize(ServerSerializationStreamWriter.java:610)<br /> at com.google.gwt.user.client.rpc.impl.AbstractSerializationStreamWriter.writeObject(AbstractSerializationStreamWriter.java:129)<br /> at com.google.gwt.user.server.rpc.impl.ServerSerializationStreamWriter$ValueWriter$8.write(ServerSerializationStreamWriter.java:152)<br /> at com.google.gwt.user.server.rpc.impl.ServerSerializationStreamWriter.serializeValue(ServerSerializationStreamWriter.java:534)<br /> at com.google.gwt.user.server.rpc.impl.ServerSerializationStreamWriter.serializeClass(ServerSerializationStreamWriter.java:700)<br /> at com.google.gwt.user.server.rpc.impl.ServerSerializationStreamWriter.serializeImpl(ServerSerializationStreamWriter.java:730)<br /> at com.google.gwt.user.server.rpc.impl.ServerSerializationStreamWriter.serialize(ServerSerializationStreamWriter.java:612)<br /> at com.google.gwt.user.client.rpc.impl.AbstractSerializationStreamWriter.writeObject(AbstractSerializationStreamWriter.java:129)<br /> at com.google.gwt.user.server.rpc.impl.ServerSerializationStreamWriter$ValueWriter$8.write(ServerSerializationStreamWriter.java:152)<br /> at com.google.gwt.user.server.rpc.impl.ServerSerializationStreamWriter.serializeValue(ServerSerializationStreamWriter.java:534)<br /> at com.google.gwt.user.server.rpc.impl.ServerSerializationStreamWriter.serializeClass(ServerSerializationStreamWriter.java:700)<br /> at com.google.gwt.user.server.rpc.impl.ServerSerializationStreamWriter.serializeImpl(ServerSerializationStreamWriter.java:730)<br /> at com.google.gwt.user.server.rpc.impl.ServerSerializationStreamWriter.serialize(ServerSerializationStreamWriter.java:612)<br /> at com.google.gwt.user.client.rpc.impl.AbstractSerializationStreamWriter.writeObject(AbstractSerializationStreamWriter.java:129)<br /> at com.google.gwt.user.server.rpc.impl.ServerSerializationStreamWriter$ValueWriter$8.write(ServerSerializationStreamWriter.java:152)<br /> at com.google.gwt.user.server.rpc.impl.ServerSerializationStreamWriter.serializeValue(ServerSerializationStreamWriter.java:534)<br /> at com.google.gwt.user.server.rpc.RPC.encodeResponse(RPC.java:609)<br /> at com.google.gwt.user.server.rpc.RPC.encodeResponseForSuccess(RPC.java:467)<br /> at com.google.gwt.user.server.rpc.RPC.invokeAndEncodeResponse(RPC.java:564)<br /> at com.google.gwt.user.server.rpc.RPC.invokeAndEncodeResponse(RPC.java:544)<br /> at com.google.gwt.user.server.rpc.RPC.invokeAndEncodeResponse(RPC.java:504)</pre><br />The exception happened during the (de)serialization of the RPC call. But I didn't use any <code>org.datanucleus.sco.backed.List</code> type in my entities which I transfer over the network. The reason however is the persist operation on App Engine. The code is like<br /><pre class="prettyprint">@Override<br />public void saveOrUpdate(SourceCodeItem item) {<br /> PersistenceManager pm = getPersistenceManager();<br /> try {<br />  pm.currentTransaction().begin();<br />  pm.makePersistent(item);<br />  pm.currentTransaction().commit();<br /> } catch (Exception ex) {<br />  if (pm.currentTransaction().isActive())<br />   pm.currentTransaction().rollback();<br /> } finally {<br />  pm.close();<br /> }<br />}</pre>It takes an object of type <code>SourceCodeItem</code> and makes it persistent by calling <code>makePersistent(...)</code>. This call to makePersistent changes the state of the passed object. The SourceCodeItem object has the following structure (cut out details):<br /><pre class="code">@PersistenceCapable(identityType = IdentityType.APPLICATION)<br />public class SourceCodeItem implements IsSerializable {<br /> @PrimaryKey<br /> @Persistent(valueStrategy = IdGeneratorStrategy.IDENTITY)<br /> @Extension(vendorName = "datanucleus", key = "gae.encoded-pk", value = "true")<br /> private String id;<br /><br /> @Persistent<br /> private String title;<br /><br /> ...<br /> <br /> <b>private List&lt;Label&gt; labels;</b><br /><br /> public SourceCodeItem() {<br />  ...<br />  <b>labels = new ArrayList&lt;Label&gt;();</b><br /> }<br /> ...<br />}</pre>The highlighted member variable declaration is a list which is not persistent and it gets initialized in the constructor. However after a call to the JDO's <code>makePersistent(..)</code> this list will be instantiated with the above mentioned <code>org.datanucleus.sco.backed.List</code> type. If you don't "detach" the object from JDOs manager it will be transferred with that instance type of the list which cannot be serialized and you'll get the exception I described in the beginning.<br /><br />Now you have two choices. Change your implementation of <code>saveOrUpdate(SourceCodeItem)</code> and explicitly detach your object. This would result in the following code:<br /><pre class="prettyprint">@Override<br />public SourceCodeItem saveOrUpdate(SourceCodeItem item) {<br />        SourceCodeItem result = null;<br /> PersistenceManager pm = getPersistenceManager();<br /> try {<br />  pm.currentTransaction().begin();<br />  pm.makePersistent(item);<br />  pm.currentTransaction().commit();<br />                result = pm.detachCopy(item);<br /> } catch (Exception ex) {<br />  if (pm.currentTransaction().isActive())<br />   pm.currentTransaction().rollback();<br /> } finally {<br />  pm.close();<br /> }<br /><br />        return result;<br />}</pre>Alternatively, which is my favorite option is to add the following to your jdoconfig.xml:<br /><pre class="code">&lt;property name="datanucleus.DetachAllOnCommit" value="true"/&gt;</pre>In this way the detaching will be done automatically after a commit and you can leave the code as it was initially. In such a way you'd get the following lifecycle:<br /><div class="separator" style="clear: both; text-align: center;"><a href="http://www.datanucleus.org/products/accessplatform_1_1/images/jdo_object_lifecycle.jpg" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="142" src="http://www.datanucleus.org/products/accessplatform_1_1/images/jdo_object_lifecycle.jpg" width="400" /></a></div>
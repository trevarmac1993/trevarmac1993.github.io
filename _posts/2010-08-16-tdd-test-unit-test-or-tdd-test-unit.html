---
layout: post
title: "TDD Test == Unit Test or TDD Test <> Unit Test?? Is it Really Important??"
date: 2010-08-16
comments: true
tags: [  annotated, testing ]
---

<p>Recently I had an interesting&nbsp;<a href="http://goo.gl/dJML">buzz conversation</a> with a former work-mate, Peter. Just like myself he heavily orientates his learning to best practices, especially into agile software development methodologies and automated testing.</p>

I was doing a refactoring session, modifying a huge part of the core logic of my Android app which I'm currently writing as a part of my MSc thesis and after succeeding I published the following message on <a href="http://twitter.com/juristr">Twitter</a>:<br /><blockquote>just #refactored application critical core logic. Would have been totally impossible without #unittest</blockquote><div><table cellpadding="0" cellspacing="0" class="tr-caption-container" style="float: right; margin-left: 1em; text-align: right;"><tbody><tr><td style="text-align: center;"><a href="http://www.doolwind.com/images/blog/TestDrivenGameDevelopment.png" imageanchor="1" rel="nofollow" style="clear: right; margin-bottom: 1em; margin-left: auto; margin-right: auto;"><img border="0" height="199" src="http://www.doolwind.com/images/blog/TestDrivenGameDevelopment.png" width="320" /></a></td></tr><tr><td class="tr-caption" style="text-align: center;">Source:&nbsp;<a href="http://www.doolwind.com/blog/" rel="nofollow">http://www.doolwind.com/blog/</a></td></tr></tbody></table>Consequently Peter reacted, asking me about whether I would say that <b>TDD tests are unit tests</b>? His question made me think...actually I never posed a similar one to myself. From a pure theory point of view I'd say <b>"not necessarily"</b>&nbsp;which was also my first answer to him.<br /><br /></div><div><b>Unit tests</b>&nbsp;are supposed to test a <b>single</b>&nbsp;unit <b>in isolation</b>. <b>TDD</b>&nbsp;- which is usually referred to as <b>T</b>est <b>D</b>riven <b>D</b>evelopment although I personally prefer&nbsp;<b>T</b>est <b>D</b>riven <b>Design</b>&nbsp;which in my opinion captures its meaning in a more precise way - tests are not said to necessarily cover a <b>single unit</b>. They are meant to <b>drive</b>&nbsp;your design s.t. it becomes incrementally (like Kent Beck calls it in his <a href="http://goo.gl/Q9St">Extreme Programming Explained</a>), <a href="http://goo.gl/wD9o">evolving</a> (evolutionary as by Fowler). So in theory they may also cover multiple units.</div><div>Apparently there is <a href="http://goo.gl/1rwq">much discussion in the community</a>&nbsp;about this difference which I never really noted so far.<br /><br /></div><div></div><div><b><u>Do we really need to be so strict?&nbsp;</u></b></div><div>When working on my Android app I proceed in a TDD way. There are days where I don't even touch the emulator but rather I do quick test-&gt;implement-&gt;test cycles which give me all the <b>feedback</b>&nbsp;I need till then comes the point of integrating everything where I will&nbsp;use the emulator to verify everything and deploy it also on real devices.<br />I also do&nbsp;write unit tests, taking my unit out of its context, verifying its correctness in isolation.&nbsp;But hey, I never ever worried about whether I was writing "unit" tests or "TDD tests". Sure, some of my TDD tests are pure unit tests and others cover 2-3 units maybe, but I've always seen the unit testing framework as the tool and TDD the methodology. Do we need to be so strict about this difference? Would it change the way we write the tests during development??<br /><br /></div><div></div><div><b><u>What really matters!!</u></b></div><div>Theory is important for learning. People need to understand the differences and it is clear that we have to highlight and express them. But ultimately what counts when working with automated tests is <b>feedback</b>.&nbsp;Those automated tests are so valuable during development because they give you a feedback, like customers will give you when you show them your app. This motivates and shows you're on the right path during development.<br />Then there is <b>regression testing</b>. Nobody is perfect and so you always again run into sub-optimal situations during development. But do you have the courage to refactor and make it better? How will you be able to know you didn't break anything else? IMHO serious refactoring cannot be done without a substantial suite of automated tests (your regression testing suite) which has an acceptable code coverage.<br /><b>TDD</b>&nbsp;is so important because it will definitely improve your design [1], [2] and more importantly it is a&nbsp;<b>test-first approach</b>. As mentioned, code coverage is important for being able to trust your tests. With a <b>test-last</b>&nbsp;approach, first you just won't be able to reach such a high code coverage as in a test-first scenario and secondly writing tests after will result in much more pain and effort.<br /><br /></div><div>What you should distinguish is between those tests that have to pass in every imaginable state of your app (usually unit tests) and those which potentially may fail or take a bit longer to succeed (typically integration tests where you access the file system, network resources, DBs...).<br /><span class="Apple-style-span" style="font-size: small;"><br /></span><br /><span class="Apple-style-span" style="font-size: small;">[1]&nbsp;D.S. Janzen and H. Saiedian. Does Test-Driven Development Really Improve&nbsp;Software Design Quality? </span><i><span class="Apple-style-span" style="font-size: small;">IEEE Software</span></i><span class="Apple-style-span" style="font-size: small;">, 25(2):77–83, 2008.</span><br /><span class="Apple-style-span" style="font-size: small;">[2] L. Crispin. Driving Software Quality: How Test-Driven Development Impacts Software Quality. </span><i><span class="Apple-style-span" style="font-size: small;">IEEE Software</span></i><span class="Apple-style-span" style="font-size: small;">, 23(6):70–71, 2006.</span></div>
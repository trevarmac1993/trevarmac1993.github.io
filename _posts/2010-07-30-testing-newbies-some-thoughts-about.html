---
layout: post
title: "Testing Newbies: Some Thoughts about Test First"
date: 2010-07-30
comments: true
tags: [  annotated, testing ]
---

A quick post just before diving into the weekend filled with <a href="http://www.yoseikan-nals.it/">Yoseikan training</a>, swimming, going out with friends and - of course - <a href="http://developer.android.com/">Android </a>coding :) . But before, I'd like to post some <b>thoughts about software&nbsp;</b><b>testing</b>&nbsp;I found on the web. These are mainly for those of you which didn't yet get into unit tests :)<br /><br />First, the <b><a href="http://blog.jtimothyking.com/2006/07/11/twelve-benefits-of-writing-unit-tests-first">twelve benefits of test-first</a></b>..<br /><ol><li><b>Unit tests prove that your code actually works.</b> That means you have fewer bugs. No, unit tests can’t replace system and acceptance testing. But they do supplement it. The fewer bugs that make it to SQA, the better.</li><li><b>You get a low-level regression-test suite.</b> You can go back at any time and see not only what broke but where the bug is. Many teams run the unit test suite as part of the nightly build. It’s a low-effort way to catch bugs before the build goes off to SQA.</li><li><b>You can improve the design without breaking it.</b> This is actually part of step 3 above, the refactoring step. So test-first code usually doesn’t need to be refactored. I have worked on some systems that were so screwed up, like a psychotic individual, you just couldn’t untangle them. Having unit tests in place, you can do powerful refactorings that can untangle the most challenging of system psychoses.</li><li><b>It's more fun to code with them than without.&nbsp;</b>You know what your code needs to do. Then you make it do it. Even if you don’t have a working system, you can see your code actually run and actually work. You get that great “I’ve done it!” feeling. Now repeat every minute or so. Just try test-first if you want to be high on endorphins, proud about your work, and motivated to do more.</li><li><b>They demonstrate concrete progress.</b>You don’t have to wait a month for all the pieces of the system to come together. You can show progress even without a working system. Not only can you say you’ve written the code, you can actually demonstrate success. Of course, this is another distinction that traditional programming teaches us to ignore. “Done” doesn’t mean you’ve written the code and checked it in. “Done” means the code actually runs in the system without bugs. Running unit tests is a step closer to the latter.</li><li><b>Unit tests are a form of sample code.&nbsp;</b>We all encounter library functions and classes we don’t know how to use. And one of the first places we go is the sample code. Sample code is documentation. But we don’t usually have samples for internal code. So we’re left sifting through the source or through the rest of the system. Because Bob, the guy who wrote that code, is no longer with the company, so we can’t actually ask him how it’s supposed to work. But unit tests are documentation. So when you can’t remember how to use class Foo, read the unit tests to find out.</li><li><b>It forces you to plan before you code.&nbsp;</b>Writing the test first forces you to think through your design and what it must accomplish before you write the code. This not only keeps you focused, it makes for better designs.</li><li><b>It reduces the cost of bugs.</b> Bugs detected earlier are easier to fix. Bugs detected later are usually the result of many changes, and we don’t know which one caused the bug. So first we have to hunt for and find the bug. Then we have to refresh our memories on how the code is supposed to work, because we haven’t seen it for months. Then finally we understand enough to propose a solution. Anything that reduces the time between when we code the bug and when we detect it seems like a obvious win. We consider ourselves lucky to find out about bugs within a few days, before the code is shipped to SQA or to customers. But how about catching them within a few minutes? That’s what test-first accomplishes with the bugs it catches.</li><li><b>It's even better than code inspections.</b> Code inspections, they say, are better than testing, because using them to detect and fix bugs is cheaper than testing. After the code ships, it’s much more expensive to fix the bugs. The earlier we can detect and fix bugs, the easier and cheaper and better. That’s the advantage of having code reviews: Code inspections catch more bugs within a few days, rather than a few months. But test-first catches some bugs within a few minutes instead of a few days. It is even cheaper than code inspections.</li><li><b>It virtually eliminates coder's block.&nbsp;</b>Ever wonder what statement to write next? Like writer’s block, coder’s block can be a real problem. But test-first systematizes the structured part of coding, allowing you to concentrate on the creative part. You may get stuck on how to test the next bit or how to make the test pass, but you’ll never be left puzzling over where to go next. In fact, usually you’re left with the opposite problem: You know you need to take a break before you burn out, but you’re on a roll and don’t want to stop.</li><li><b>Unit tests make better designs.</b> Testing a piece of code forces you to define what that code is responsible for. If you can do this easily, that means the code’s responsibility is well-defined and therefore that it has high cohesion. And if you can unit-test your code, that means you can bind it as easily to the test as to the rest of the system. Therefore, it has loose coupling to the pieces around it. High cohesion and loose coupling is the definition of good, maintainable design. Code that is easy to unit-test is also easy to maintain.</li><li><b>It's faster than writing code without tests. </b>Or to put it another way, skipping unit tests is faster, unless you actually need the code to work. Most of the effort we spend on code, we spend fixing it after we’ve checked it in to the source-code repository. But test-first eliminates much of that waste by allowing us to get more of it right to start with and by making bugs easier to fix.</li></ol>These points pretty much include most of the benefits. Btw&nbsp;I found them <a href="http://blog.jtimothyking.com/2006/07/11/twelve-benefits-of-writing-unit-tests-first">here </a>in case you want to read the whole post.<br /><br />Second, I recommend you to also read <a href="http://www.codinghorror.com/blog/2006/07/i-pity-the-fool-who-doesnt-write-unit-tests.html">Codinghorror's post</a> which basically discusses the one above listing the twelve points.<br /><br />Have a nice weekend!
---
layout: post
title: "Load JavaScript Files Asynchronously"
date: 2011-04-03
comments: true
tags: [  JavaScript, Web dev, jQuery ]
---

<p>I recently worked on a component for our single-sign-on system. As part of that work I also developed a small JavaScript file that was included in the top-header of the page for rendering the username, last access and session expiration or alternatively the login link in case the user wasn't logged on.</p>

The different pages included the JavaScript in their HTML just normally, such as<br /><pre class="brush:html;highlight:[8]">&lt;html&gt;<br />&lt;head&gt;<br />   ...<br />   &lt;script type="text/javascript" src="./..."&gt;&lt;/script&gt;<br />&lt;/head&gt;<br />&lt;body&gt;<br />   &lt;div id="header"&gt;<br />      &lt;script type="text/javascript" src="https://authserver.com/AuthenticationHeaderScript"&gt;&lt;/script&gt;<br />   &lt;/div&gt;<br />   ...<br />&lt;/body&gt;<br />&lt;/html&gt;<br /></pre>The included script directly rendered the html in the place where it was included. <b>The problem</b>&nbsp;with this is how the browser loads such scripts: "synchronously". &nbsp;Basically when it encounters a <code>&lt;script&gt;</code> tag it loads it and waits for its content to arrive. To cap it all, we had some issues with the server that provided that authentication script I mentioned above. What happened was that all pages remained basically blank, because they hung at trying to load that JavaScript.<br /><br />To overcome this, we took the approach to load the script "asynchronously". jQuery provides a nice function for doing that. <code>$.getScript("...")</code>&nbsp;allows to<br /><blockquote>Load a JavaScript file from the server using a GET HTTP request, then execute it.<br /><span class="Apple-style-span" style="font-size: x-small;"><i>jQuery: <a href="http://api.jquery.com/jQuery.getScript/">http://api.jquery.com/jQuery.getScript/</a></i></span></blockquote>By wrapping this call in the jQuery ready() function, one postpones the loading of the script till the very end of the page construction which is much better for the user experience as he sees the page content more quickly. To improve this even more, one could introduce a timeout for loading the script. If it doesn't load within 20 seconds, the request could be aborted. This is done by calling the <code>abort()</code> function on the ajax request.<br /><pre class="brush:javascript">//store the request in a variable<br />var ajaxRequest = $.getScript("http://somelocation.com/myscript.js");<br />...<br />//to abort<br />ajaxRequest.abort();<br /></pre>The final result looks something like this:<br /><pre class="brush:javascript; highlight:[7,13,14]">&lt;script type="text/javascript"&gt;<br />    var timeoutLength = 20000;<br />    var timer;<br />    var ajaxRequest;<br />    $(document).ready(function() {<br />        isRunning = true;<br />        timer = setTimeout(function() {<br />            if (ajaxRequest) {<br />                ajaxRequest.abort();<br />                clearTimeout(timer);<br />            }<br />        }, timeoutLength);<br />        ajaxRequest = $.getScript("http://authserver.com/AuthenticationScript.js", function() {<br />            $("#header").prepend(authCtrlScript);<br />            clearTimeout();<br />        });<br />    });<br />&lt;/script&gt;</pre><b>Line 7</b>&nbsp;shows the initialization of the timer by initializing a timeout function. In the callback, the ajax request is being aborted. In <b>line 13</b>&nbsp;the invocation of the ajax request is demonstrated and subsequently the implementation of the success callback is shown in <b>line 14</b>.
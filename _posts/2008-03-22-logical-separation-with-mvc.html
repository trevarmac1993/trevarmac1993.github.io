---
layout: post
title: "Logical separation with MVC"
date: 2008-03-22
comments: true
tags: [  Java, Design Patterns ]
---

I'm currently working on a personal project (which I'll publish here, so keep an eye on my blog ;) ) which I wanted to construct optimally in terms of the architecture. So today I decided to take a piece from the architectural part of my Bsc. thesis and publish it on my blog here. In specific I'll write about the MVC paradigm.<br /><br />MVC is the acronym for "Model View Controller" and is a design pattern whose aim is to logically separate the application into a model-,controller- and view-part.<br />The <span style="font-style: italic;">Model </span>comprises the domain model objects of the application. It contains the data and encodes the rules for giving access to this data.<br />The <span style="font-style: italic;">View</span> is the end-point of the application which interacts directly with the user by presenting the data contained in the model. If the model changes the view has to be updated. This can be done by using the so-called "push" approach where the view registers itself at the model for changes or the "pull" approach where the view itself has to call the appropriate methods on the model for retrieving the updated information.<br />The <span style="font-style: italic;">Controller</span> translates the user interactions on the view into actions on the model.<br /><br />This figure shows a common MVC implementation:<br /><br /><a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://4.bp.blogspot.com/_tF6XjsUy87k/R-LFoIgjwkI/AAAAAAAABDI/3n_15T7qHro/s1600-h/mvc_trad.gif"><img style="margin: 0px auto 10px; display: block; text-align: center; cursor: pointer;" src="http://4.bp.blogspot.com/_tF6XjsUy87k/R-LFoIgjwkI/AAAAAAAABDI/3n_15T7qHro/s400/mvc_trad.gif" alt="" id="BLOGGER_PHOTO_ID_5179919814698975810" border="0" /></a>Here the view registers itself on the model for listening to property changes. User interactions on the view are forwarded to the controller which performs some actions on the model. These changes of properties on the model side are again reflected on the view (since the view listens  for changes on it). The  disadvantage of this kind of MVC structure is the coupling between  the view and the model.<br />Therefore I prefer a slightly different and more recent implementation of the MVC paradigm. The figure below outlines its basic structure.<br /><a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://3.bp.blogspot.com/_tF6XjsUy87k/R-LFi4gjwjI/AAAAAAAABDA/XlB6HUUaMcQ/s1600-h/mvc_new.gif"><img style="margin: 0px auto 10px; display: block; text-align: center; cursor: pointer;" src="http://3.bp.blogspot.com/_tF6XjsUy87k/R-LFi4gjwjI/AAAAAAAABDA/XlB6HUUaMcQ/s400/mvc_new.gif" alt="" id="BLOGGER_PHOTO_ID_5179919724504662578" border="0" /></a>In this example the view and the model are completely separated and work independently. The controller works as mediator between them by forwarding the according user actions from the view down to the model and the respective property change events back up to the view. This kind of structure keeps the application much more flexible and more loosely coupled. The view could be exchanged with nearly no changes since it doesn't know anything about the domain model it is representing.<br />Sounds nice, doesn't it?? But to not just illustrate the theoretical aspects and for a better understanding I decided to code a small demo application according to which one is able to better understand the concepts I was talking about above. Before starting to talk about it you can download it from my <a href="http://code.google.com/p/juri-strumpflohner-projects/downloads/list">Open Source projects download page</a>:<br /><div style="text-align: center;"><span style="font-size:130%;"><a href="http://juri-strumpflohner-projects.googlecode.com/files/mvcdemo1.0.jar">Download MVC Demo</a><br /></span></div>The application just manages a list of people. The available operations are to add a new person and to modify its properties. Nonsense, but it helps understanding MVC. The application consists of 3 different windows.<br /><a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://1.bp.blogspot.com/_tF6XjsUy87k/R-Lb7YgjwlI/AAAAAAAABDQ/7fWxnA-SZVw/s1600-h/mvcdemo.png"><img style="margin: 0px auto 10px; display: block; text-align: center; cursor: pointer;" src="http://1.bp.blogspot.com/_tF6XjsUy87k/R-Lb7YgjwlI/AAAAAAAABDQ/7fWxnA-SZVw/s400/mvcdemo.png" alt="" id="BLOGGER_PHOTO_ID_5179944334667268690" border="0" /></a>I decided to structure it like this, since in this way one can better see how the changes are done by the MVC and how the view is updated "magically" when the model is changed. When the user presses for instance the "Add new Person" button, the application directly adds a new Person object to the application model. The list of people of the window in the center is never touched, but since it is linked with the MVC to the application model, it automatically gets the new added person object.<br /><br />But now lets take a look at the interesting part: the source code. In principle there are 3 major important classes which make up our MVC helper utility and which are subclassed by the corresponding domain objects of our application:<br /><ul><li>AbstractModel (abstract class)<br /></li><li>AbstractController (abstract class)<br /></li><li>IView (interface)</li></ul><span style="font-size:130%;">AbstractModel.java</span><br /><pre class="prettyprint">package com.jsdevelopment.mvcdemo.mvcutils;<br /><br />import java.beans.PropertyChangeListener;<br />import java.beans.PropertyChangeSupport;<br /><br />public abstract class AbstractModel{<br />   protected PropertyChangeSupport propertyChangeSupport;<br /><br />   public AbstractModel(){<br />       propertyChangeSupport = new PropertyChangeSupport(this);<br />   }<br /><br />   public void addPropertyChangeListener(PropertyChangeListener listener) {<br />       propertyChangeSupport.addPropertyChangeListener(listener);<br />   }<br /><br />   public void removePropertyChangeListener(PropertyChangeListener listener) {<br />       propertyChangeSupport.removePropertyChangeListener(listener);<br />   }<br /><br />   protected void firePropertyChange(String propertyName, Object oldValue, Object newValue) {<br />       propertyChangeSupport.firePropertyChange(propertyName, oldValue, newValue);<br />   }<br />  <br />   protected void fireInitialProperties(){<br />   }<br />}<br /></pre>The AbstractModel is subclassed by our domain model classes, adding the property change support to them. The changes we have to do on our model are just the following:<br /><pre class="prettyprint"><br />package com.jsdevelopment.mvcdemo.model;<br /><br />import com.jsdevelopment.mvcdemo.controller.PersonController;<br />import com.jsdevelopment.mvcdemo.mvcutils.AbstractModel;<br /><br />public class Person extends <b>AbstractModel</b> {<br />private String firstname;<br />private String surname;<br />private int age;<br /><br />...<br /><br />public void setAge(Integer age) {<br /> ...<br />}<br /><br />...<br /><br />public void setFirstname(String firstname) {<br /> String oldValue = this.firstname;<br /> this.firstname = firstname;<br /> <b>firePropertyChange(PersonController.FIRSTNAME_PROPERTY, oldValue, firstname);</b><br />}<br /><br />..<br /><br />public void setSurname(String surname) {<br /> ...<br />}<br /><br />public void fireInitialProperties(){<br /> firePropertyChange(PersonController.AGE_PROPERTY, null, age);<br /> firePropertyChange(PersonController.FIRSTNAME_PROPERTY, null, firstname);<br /> firePropertyChange(PersonController.SURNAME_PROPERTY, null, surname);<br />}<br />...<br />}<br /></pre>I've hidden the getters, since the interesting part here are the setters since the action happens there. Take for instance the <span class="code">setFirstname(String)</span> method. What I do there is to keep the old value, then I set the new value, just as usual and then we fire the property-change event which we inherited from the AbstractModel class.<br />Lets move over to our AbstractController. Here's the abbreviated source code:<br /><br /><span style="font-size:130%;">AbstractController.java</span><br /><pre class="prettyprint">package com.jsdevelopment.mvcdemo.mvcutils;<br />...<br />public abstract class AbstractController implements PropertyChangeListener {<br /><br />   private ArrayList&lt;IView&gt; registeredViews;<br />   private ArrayList&lt;AbstractModel&gt; registeredModels;<br /><br />   public AbstractController() {<br />       registeredViews = new ArrayList&lt;IView&gt;();<br />       registeredModels = new ArrayList&lt;AbstractModel&gt;();<br />   }<br /><br /> ...<br /><br />   public void <b>propertyChange(PropertyChangeEvent evt)</b> {<br /><br />       for (IView view: registeredViews) {<br />           view.modelPropertyChange(evt);<br />       }<br />   }<br /><br />   protected void <b>setModelProperty(String propertyName, Object newValue)</b> {<br /><br />       for (AbstractModel model: registeredModels) {<br />           try {<br /><br />               Method method = model.getClass().<br />                   getMethod("set"+propertyName, new Class[] {<br />                                                     newValue.getClass()<br />                                                 }<br /><br /><br />                            );<br />               method.invoke(model, newValue);<br /><br />           } catch (Exception ex) {<br />               //  Handle exception.<br />           }<br />       }<br />   }<br />}<br /></pre>The AbstractController class is mainly responsible for propagating the corresponding events either from the model to the view or vice-versa. The following two methods are especially interesting since they are somehow the core of the MVC:<br /><ul><li><span style="font-style: italic;">propertyChange(PropertyChangeEvent)</span><br />This method is responsible for propagating a change of a property from the model to the view. As you can see it iterates over the list of registered views and calls the method modelPropertyChange(...) which is implemented by our views.<br /></li><li><span style="font-style: italic;">setModelProperty(String, Object)</span><br />This method - as you probably guess already - is responsible for propagating the user-actions on the view down to the model. This method is especially tricky since it uses the Java reflection mechanism for finding the right method to invoke. As you can see from the code above it calls the setter on the registered models which corresponds to the given property-event.</li></ul>Our specific controller - in this demo application the PersonController - has not much to do actually:<br /><pre class="prettyprint">package com.jsdevelopment.mvcdemo.controller;<br /><br />import com.jsdevelopment.mvcdemo.mvcutils.AbstractController;<br /><br />/**<br />* Controller for synchronizing the Person domain object<br />* with the respective View<br />*<br />*/<br />public class PersonController extends <b>AbstractController</b> {<br />public static final String FIRSTNAME_PROPERTY = <b>"Firstname"</b>;<br />public static final String SURNAME_PROPERTY = "Surname";<br />public static final String AGE_PROPERTY = "Age";<br /><br />public PersonController(){<br />}<br /><br />public void changeFirstName(String newValue){<br /> <b>setModelProperty(FIRSTNAME_PROPERTY, newValue)</b>;<br />}<br /><br />public void changeSurname(String newValue){<br /> setModelProperty(SURNAME_PROPERTY, newValue);<br />}<br /><br />public void changeAge(String newValue){<br /> Integer value = Integer.parseInt(newValue);<br /> setModelProperty(AGE_PROPERTY, value);<br />}<br />}</pre>So, lets see what's interesting here. For the first you can see that it inherits from our AbstractController class we've seen before. The next thing which catch one's eye are the static constants defined at the beginning. If you take a look at the AbstractModel you'll see that these constants are used for identifying the type of property change. Moreover in the <span class="code">AbstractController.setModelProperty(...)</span> method it is used for constructing the right signature of the setter-method of the domain model which has to be invoked. And then there are the different methods such as changeFirstName and so on. These methods are directly called by the view (we'll see that below) and they then call the <span class="code">setModelProperty(...)</span> method for propagating the change down to the model.<br />Finally we can move on to the 3rd component: the view.<br /><br /><span style="font-size:130%;">IView.java</span><br /><pre class="prettyprint">package com.jsdevelopment.mvcdemo.mvcutils;<br /><br />import java.beans.PropertyChangeEvent;<br /><br />public interface IView {<br />public void modelPropertyChange(PropertyChangeEvent evt);<br />}</pre>This class is really simple. It is implemented as an interface for grouping all of our views together and for constraining them to implement the <span class="code">modelPropertyChange(...)</span> method which is called by the AbstractController. The essential parts on our view are then the following:<br /><pre class="prettyprint">package com.jsdevelopment.mvcdemo.view;<br />...<br /><br />import com.jsdevelopment.mvcdemo.controller.PersonController;<br />import com.jsdevelopment.mvcdemo.mvcutils.AbstractController;<br />import com.jsdevelopment.mvcdemo.mvcutils.IView;<br /><br />public class PersonView extends JFrame implements <b>IView</b> {<br />...<br />private PersonController controller = null;<br />...<br /><br />/**<br /> * This method initializes<br /> *<br /> */<br />public PersonView(<b>AbstractController controller</b>) {<br /> super();<br /> initialize();<br /> this.controller = (PersonController)controller;<br />}<br /><br />...<br /><br />private JButton getJButtonSave() {<br /> if (jButtonSave == null) {<br />  jButtonSave = new JButton();<br />  jButtonSave.setBounds(new Rectangle(112, 102, 70, 24));<br />  jButtonSave.setText("Save");<br />  jButtonSave.addActionListener(new java.awt.event.ActionListener() {<br />   public void actionPerformed(java.awt.event.ActionEvent e) {<br />    //fire all property changes<br /><b>     controller.changeFirstName(jTextFieldFirstname.getText());<br />    controller.changeSurname(jTextFieldSurname.getText());<br />    controller.changeAge(jTextFieldAge.getText());</b><br />    closeFrame();<br />   }<br />  });<br /> }<br /> return jButtonSave;<br />}<br /><br />public void <b>modelPropertyChange(PropertyChangeEvent evt)</b> {<br /> if(evt.getNewValue() == null) return;<br /><br /> String value = evt.getNewValue().toString();<br /><br /> if(evt.getPropertyName().equals(PersonController.FIRSTNAME_PROPERTY)){<br />  jTextFieldFirstname.setText(value);<br /> }else if(evt.getPropertyName().equals(PersonController.SURNAME_PROPERTY)){<br />  jTextFieldSurname.setText(value);<br /> }else if(evt.getPropertyName().equals(PersonController.AGE_PROPERTY)){<br />  jTextFieldAge.setText(value);<br /> } <br />}<br />}<br /></pre>The first thing here is to get a reference to our actual controller class. In my example here this is done directly in the constructor. Once could however also do this with a separate setter. If you go further, you'll come to the listener attached to the save button. I've decided to propagate all actions down to the model when the save-button is clicked. So what I do there is just to call the methods of my controller which we have seen before. That's all. Finally we have our modelPropertyChange(...) method which we inherited from our IView interface (remember?) and which is implemented here. This method gets invoked when our AbstractController gets an property-change event notification from one of our domain objects. Here we just ask which property has been fired and then we set the value on the appropriate view control.<br /><br />So since we've covered now the critical part lets move over to the actual binding of these components. In my demo application this is done in the ApplicationController:<br /><pre class="prettyprint">package com.jsdevelopment.mvcdemo.controller;<br /><br />import com.jsdevelopment.mvcdemo.model.Person;<br />import com.jsdevelopment.mvcdemo.mvcutils.AbstractController;<br />import com.jsdevelopment.mvcdemo.view.PersonView;<br /><br /><br />public class ApplicationController extends AbstractController {<br />...<br /><br />public void showPersonView(Object selectedValue) {<br /> //construct the MVC binding<br /> Person p = (Person)selectedValue;<br /> pController = new PersonController();<br /> PersonView pView = new PersonView(pController);<br /> pController.addModel(p);<br /> pController.addView(pView);<br /><br /><br /> //show the view<br /> pView.setVisible(true);<br /><br /> //display initial properties on view by firing the property actions<br /> p.fireInitialProperties();<br />}<br />}</pre>Here inside the <span class="code">showPersonView(...)</span> method I simply create a new PersonController object and I associate the given domain object of type Person and add it to the controller as well as the reference of my view which will present the content of the object to the end-user. This piece of code is just to demonstrate the binding and may not be that optimal. So it is not really advisable to create a new controller object each time but you'd have to maybe create it the first time and then to register and unregister the different models and views. What may still make you wonder is the last line where I invoke the <span class="code">fireInitialProperties()</span> method. This is done to fill the view with the initial values of the domain object (if it contains some).<br /><br />Well, that was it. Easy isn't it ;). The best thing is again to <a href="http://juri-strumpflohner-projects.googlecode.com/files/mvcdemo1.0.jar">download the demo application</a> and study its source code which is included in the archive. Otherwise you can also access it on the public <a href="http://code.google.com/p/juri-strumpflohner-projects/source/checkout">SVN repository</a>. Feel free to put your comment if you have further question or suggestions for better solutions.<br /><br />Here's a post on the Google Testing blog that highlights the advantages of such an MVC structure:<br /><a href="http://googletesting.blogspot.com/2009/02/with-all-sport-drug-scandals-of-late.html">http://googletesting.blogspot.com/2009/02/with-all-sport-drug-scandals-of-late.html</a>
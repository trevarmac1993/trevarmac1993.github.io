---
layout: post
title: "MapView doesn't fire onLongClick event"
date: 2009-12-02
comments: true
tags: [  Java, mobile dev, Android ]
---

<p>Here's another curiosity I came across today while programming on my Android project. I was creating a MapView for displaying some interesting stuff on it.</p>

Update: This post got a bit lengthy due to different problems that popped up while I was writing the post. So if you prefer to jump directly due to the final solution, feel free <a href="#solution">to do so</a>.
<br/><br/>

Now there are different events the user may interact when having a map on the screen like just simple clicks or even moves when navigating on the map. So first of all I have my MapActivity class which again loads a MapView on it, defined in some layout xml file. So far so good. For reacting on click or move events I had to override the MapActivities "dispatchOnTouchEvent" method.<br /><pre class="prettyprint">public class MyMapActivity extends MapActivity {<br />   ...<br />   @Override<br />   public void onCreate(...){<br />      super.onCreate(...);<br />      setContentView(R.layout.mymapviewlayout);<br /><br />      this.mapView = (MapView)findViewById(R.id.myMapView);<br />      this.mapView.set....<br />      ...<br />      this.mapView.setClickable(true);<br />      ...<br />   }<br /><br />   @Override<br />   public boolean dispatchTouchEvent(MotionEvent ev) {<br />      int actionType = ev.getAction();<br />      switch (actionType) {<br />         case MotionEvent.ACTION_MOVE:<br />       //react properly<br />              break;<br />      }<br /><br />      return super.dispatchTouchEvent(ev);<br />   }<br />   ...<br />}</pre>That worked pretty well. Now comes the strange behavior. I wanted to differentiate the action of a simple click (press down with immediate release) from a longer click (press down, hold a while and then release again). A fast search on the Android docs revealed the "setOnLongClickListener(OnLongClickListener)" method. Pretty nice, so I just needed to implement the listener an that's it? Actually that didn't work I adjusted my view s.t. it sets the necessary flags and implements the correct listeners...<br /><pre class="prettyprint">public class MyMapActivity extends MapActivity {<br />   ...<br />   @Override<br />   public void onCreate(...){<br />      ...<br />      this.mapView.setClickable(true);<br />      this.mapView.setLongClickable(true);<br />      //direct listener implementation<br />      mapView.setOnLongClickListener(new OnLongClickListener() {<br />         public boolean onLongClick(View v) {<br />            //react<br />            return false;<br />         }<br />      });<br />      ...<br />   }<br /><br />   ...<br />}</pre>...however with no success. The event just didn't fire. I also tried to adapt the overridden dispatchTouchEvent method s.t. it forwards the event to the MapView like<br /><pre class="prettyprint">@Override<br />   public boolean dispatchTouchEvent(MotionEvent ev) {<br />      int actionType = ev.getAction();<br />      switch (actionType) {<br />         case MotionEvent.ACTION_MOVE:<br />       //react properly<br />              break;<br />      }<br /><br />      return this.mapView.dispatchTouchEvent(ev);<br />   }<br /></pre>..which would sound plausible, however with no success.<br /><br />So the final solution I came up with was to add a <a href="http://developer.android.com/reference/android/view/GestureDetector.html">GestureDetector</a> to my MapActivity and delegate all touch events to that object. The according OnGestureListener implements a couple of event handlers, under which also the "onLongPress(...)" event handler. So I had to change my implementation to the following<br /><pre class="prettyprint">public class MyMapActivity extends MapActivity implements <b>OnGestureListener</b> {<br />   ...<br />   <b>private GestureDetector gestureDetector;</b><br /><br />   @Override<br />   public void onCreate(...){<br />      super.onCreate(...);<br />      setContentView(R.layout.mymapviewlayout);<br /><br />      <b>this.gestureDetector = new GestureDetector(this);</b><br />      <b>this.gestureDetector.setIsLongpressEnabled(true);</b><br /><br />      this.mapView = (MapView)findViewById(R.id.myMapView);<br />      this.mapView.set....<br />      ...<br />      this.mapView.setClickable(true);<br />      ...<br />   }<br /><br />   @Override<br />   public boolean dispatchTouchEvent(MotionEvent ev) {<br />      int actionType = ev.getAction();<br />      switch (actionType) {<br />         case MotionEvent.ACTION_MOVE:<br />       //react properly<br />              break;<br />      }<br /><br />      <b>return gestureDetector.onTouchEvent(ev);</b><br />   }<br />   ...<br /><br />   //other methods of the OnGestureListener interface<br />   public void onLongPress(MotionEvent e) {<br />      ActivityUtils.showToast(this, "Pushed down", 3000);<br />   }<br />   ...<br />}</pre>The result after doing a "long click" on the map:<br /><div class="separator" style="clear: both; text-align: center;"><a href="http://1.bp.blogspot.com/_tF6XjsUy87k/SxbriADZ62I/AAAAAAAACfI/qJdPY_2241w/s1600/MapView.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="400" src="http://1.bp.blogspot.com/_tF6XjsUy87k/SxbriADZ62I/AAAAAAAACfI/qJdPY_2241w/s400/MapView.png" width="271" /></a><br /></div>That looks like it works :) . Don't ask me why it didn't work by just attaching the OnLongClickListener on the map and dispatching events to the MapView. It's now 11:40 PM and I think it's time to have a bit of sleep.<br /><br /><b><a name="solution">Update:</a></b><br />Indeed, it was late last night. Today morning when I launched my MapView the onLongClick worked, but everything else didn't work any more including move events click events etc. The reason is obvious: I forward everything to my GestureDetector wherefore the MapView will never get the events.<br />Due to a suggestion of Paul (see comments), I checked the inheritance hierarchy of the MapView and it inherits from ViewGroup. The LongClick event is defined on the level of the View object and for some reason the MapView doesn't react on it nor it lets you override the behavior.<br /><br />So the final solution to the problem is to handle it on your own. What I did is to create my custom MapView which inherits from MapView. On that class I've overriden the onTouch event and made some kind of hack on it to achieve a long-touch event. The approach was basically to measure the time between the MotionEvent.ACTION_DOWN and the MotionEvent.ACTION_UP event.<br /><pre class="prettyprint">public class MyMap extends MapView{<br />   ...<br /><br />   public MyMapView(Context context, AttributeSet attrs) {<br />      super(context, attrs);<br />   }<br /><br />   @Override<br />   public boolean onTouchEvent(MotionEvent ev) {<br />      if(ev.getAction() == MotionEvent.ACTION_DOWN){<br />         //record the start time<br />         startTime = ev.getEventTime();<br />      }else if(ev.getAction() == MotionEvent.ACTION_UP){<br />         //record the end time<br />         endTime = ev.getEventTime();<br />      }<br /><br />      //verify<br />      if(endTime - startTime &gt; 1000){<br />         //we have a 1000ms duration touch<br />         //propagate your own event<br />         return true; //notify that you handled this event (do not propagate)<br />      }<br />   }<br /><br />}<br /></pre>What I left out here (since I don't want you to steal your own creativity ;) ) is to handle moves on the map which may also otherwise result in a long click. It's quite simple to fix that.
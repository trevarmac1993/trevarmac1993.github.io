---
layout: post
title: "HowTo: testing jFace Action class taking a StructuredSelection object"
date: 2009-01-15
comments: true
tags: [  HowTo, jFace, Java, RCP, Eclipse, testing ]
---

Let's consider the following jFace Action class:<br /><pre class="prettyprint">public class RateAction extends Action {<br /> private final int fRating;<br /> private IStructuredSelection fSelection;<br /><br /> /**<br />  * @param rating<br />  * @param selection<br />  */<br /> public RateAction(int rating, IStructuredSelection selection) {<br />  //hack: have to use a button because otherwise the star images won't show up on Linux (Ubuntu)<br />  super("", AS_PUSH_BUTTON);<br />  fRating = rating;<br />  fSelection = selection;<br /><br />  setImageDescriptor(createImageDescriptor());<br /> }<br /><br /> ...<br /><br /> /*<br />  * @see org.eclipse.jface.action.Action#run()<br />  */<br /><br /> @Override<br /> public void run() {<br />  List&lt;INews&gt; newsList = ModelUtils.getEntities(fSelection, INews.class);<br />  if (newsList.isEmpty())<br />   return;<br /><br />  /* For each News */<br />  for (INews newsItem : newsList) {<br />   newsItem.setRating(fRating);<br />  }<br /><br />  /* Save */<br />  DynamicDAO.saveAll(newsList);<br /> }<br />}</pre>Action classes are heavily used in the <a href="http://www.eclipse.org/pde/">Eclipse plugin development environment</a>. They are basically nothing other than the representation of the Command design pattern, which is an extremely useful pattern. For instance for factoring out/grouping common behavior. Do not always put it in a common superclass: inheritance should only be used for specialization and moreover it imposes a very strong dependency among the classes. Command objects can be easily exchanged and are much lower coupled.<br />But back to the main purpose of this post. Another advantage of the Command pattern is to increase testability. So the above Action class can be tested as follows. The only peculiarity in this specific case may on how to create the appropriate StructuredSelection object which is normally automatically provided by the jFace environment. But also this is quite straightforward as can be seen:<br /><pre class="prettyprint">public class RateActionTest {<br /> private RateAction action = null;<br /> private INews newsItem = null;<br /> private IStructuredSelection selection = null;<br /> <br /> @Before<br /> public void setUp() throws Exception {<br />  //reset DB schema<br />  Owl.getPersistenceService().recreateSchema();<br />  <br />  //construct the necessary selection<br />  IFeed feed = new Feed(Long.parseLong("" + 0), new URI("http://www.dummyurl.com"));<br />  newsItem = new News(feed);<br />  <b>selection = new StructuredSelection(newsItem);</b><br /> }<br /><br /> @After<br /> public void tearDown() throws Exception {<br />  selection = null;<br />  newsItem = null;<br />  action = null;<br /> }<br /> <br /> /**<br />  * Tests the actions core parts<br />  */<br /> @Test<br /> public void testAction(){<br />  assertNotNull(newsItem);<br /><br />  //Verify that the created newsItem has a rating of 0<br />  assertEquals("rating should be equal to 0", 0, newsItem.getRating());<br /><br />  //boundary test: empty selection -&gt; nothing should happen, no exception etc..<br />  action = new RateAction(3, new StructuredSelection());<br />  action.run();<br />  <br />  //start the Action and set some rating<br />  <b>action = new RateAction(3, selection);</b><br />  action.run();<br />  assertEquals("rating should be equal to 3", 3, newsItem.getRating());<br />  <br />  //decrease the rating again<br />  action = new RateAction(1, selection);<br />  action.run();<br />  assertEquals("rating should be equal to 1", 1, newsItem.getRating());<br /> } <br />}</pre>
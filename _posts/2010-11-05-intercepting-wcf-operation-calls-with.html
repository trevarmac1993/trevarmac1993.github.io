---
layout: post
title: "Intercepting WCF Operation Calls with Impersonated Identity"
date: 2010-11-05
comments: true
tags: [  C#, .Net, WCF ]
---

<p>Take the following scenario. You have a WCF webservice with several operations. The communication runs within a secure SSL channel and uses Kerberos authentication. The webservice application runs with an assigned application pool user, in your .Net code represented by the WindowsIdentity.</p>

The requirement is to make a call to another webservice - let's call it the authorization service - which takes the currently authenticated Identity and performs some further business logic in order to determine whether the user has the right to access given resources.<br />What comes immediately to mind is that we need to impersonate the caller in order to have the right identity sent to the authorization service. Otherwise we'd get the application pool user identity transferred which would be nonsense. Impersonation on WCF operations turns out to be quite straightforward. All you need is to annotate your operation with the right attribute<br /><pre class="brush:c#">[OperationBehavior(Impersonation = ImpersonationOption.Required)]<br />public string Hello(string message)<br />{<br />   //execute the call to the authorization service<br /><br />   //if the current identity is authorized execute the custom<br />   //business logic<br /><br />   return "hello";<br />}</pre>This would work. I don't like this approach however. The problem is that most of the webservices would need to first check the user authorization by calling the authorization service. So every single programmer would need to implement the call which is not an acceptable, clean solution and way too much error prone.

<h2>Solution approach 1: Implement a custom WCF authorization policy</h2>
WCF allows you to specify so-called authorization policies. All you need to do is to implement the <code>IAuthorization</code> interface appropriately.<br /><pre class="brush:c#">public class MyCustomAuthorizationPolicy : IAuthorizationPolicy<br />{<br /><br />   public boolean Evaluate(EvaluationContext context)<br />   {<br />      evaluationContext.Properties["Principal"] = //call the authorization service to retrieve an appropriate principal<br />      ...<br />   }<br />}<br /></pre>In the service's configuration you need to register your policy<br /><script class="brush:xml" type="syntaxhighlighter"><![CDATA[ <serviceauthorization principalpermissionmode="Custom">   <authorizationpolicies>      <add policytype="MyNamespace.MyCustomAuthorizationPolicy, AssemblyName"/>   </authorizationpolicies></serviceauthorization>  ]]></script><br />This is a nice mechanism because it allows you to decouple the authorization logic (i.e. the call to the authorization service) from the real business logic. Your webservice operation doesn't even get called.<br />The problem with this approach however is that I was not able to impersonate the caller at this level.

<h2>Solution approach 2: Parameter Inspectors</h2>
Not succeeding with custom authorization policies I tried to find an alternative to intercept the WS call in order to to my authorization logic. Parameter inspectors seemed to be suitable at first glance. Their main purpose is to do parameter validation.<br /><pre class="brush:c#">public void AfterCall(string operationName, object[] outputs, object returnValue, object correlationState)<br />{ }<br /><br />public object BeforeCall(string operationName, object[] inputs)<br />{ }<br /></pre>The method names are quite self-explanatory. However, you already guessed it, impersonation didn't work at this level neither.

<h2>Final approach and solution</h2>
My last hope was to rely on <b>OperatonInvokers</b>. They are the last one to be called in the chain of calls (see below) that are executed when a webservice operaton gets invoked.<br /><ol><li>Message Inspection</li><li>Operation Selector</li><li>Message Formatting</li><li>Parameter Inspection</li><li><b>Operation Invoker</b></li></ol>The main methods of interest in the <code>IOperationInvoker</code> interface are the <code>Invoke(...)</code>, <code>BeginInvoke(...)</code> and <code>EndInvoke(...)</code><br /><br /><b>Invoke -</b> Returns an object and a set of output objects from an instance and set of input objects.<br /><b>BeginInvoke -</b> An asynchronous implementation of the Invoke method.<br /><b>EndInvoke -</b> The asynchronous end method.<br /><br />So, my custom operation invoker implementation turned out to be as follows<br /><pre class="brush:c#; highlight: [7,17]">class AuthenticationOperationInvoker : IOperationInvoker<br />{<br />    private IOperationInvoker defaultInvoker;<br /><br />    public AuthenticationOperationInvoker(IOperationInvoker defaultInvoker)<br />    {<br />        this.defaultInvoker = defaultInvoker;<br />    }<br /><br />    public object[] AllocateInputs()<br />    {<br />        return defaultInvoker.AllocateInputs();<br />    }<br /><br />    public object Invoke(object instance, object[] inputs, out object[] outputs)<br />    {<br />        //execute the custom authorization logic and set the thread principal accordingly<br /><br />        return defaultInvoker.Invoke(instance, inputs, out outputs);<br />    }<br /><br />    public IAsyncResult InvokeBegin(object instance, object[] inputs, AsyncCallback callback, object state)<br />    {<br />        return defaultInvoker.InvokeBegin(instance, inputs, callback, state);<br />    }<br /><br />    public object InvokeEnd(object instance, out object[] outputs, IAsyncResult result)<br />    {<br />        return defaultInvoker.InvokeEnd(instance, out outputs, result);<br />    }<br /><br />    public bool IsSynchronous<br />    {<br />        get { return defaultInvoker.IsSynchronous; }<br />    }<br />}<br /></pre>Note, my custom OperationInvoker is mainly a wrapper, taking the default operation invoker in the constructor and delegating all operations to it in order to not break anything existing. In line 17, within the Invoke method I do inject my custom authorization logic and <b>yes, here impersonation works</b>.<br /><br />To make this whole thing usable I wrap everything in a custom "authorization attribute" which implements the <code>IOperationBehavior</code> interface.<br /><pre class="brush:c#; highlight:[11,12]">public class AuthorizedMethodAttribute : Attribute, IOperationBehavior<br />{<br />    public void AddBindingParameters(OperationDescription operationDescription, System.ServiceModel.Channels.BindingParameterCollection bindingParameters)<br />    { }<br /><br />    public void ApplyClientBehavior(OperationDescription operationDescription, System.ServiceModel.Dispatcher.ClientOperation clientOperation)<br />    { }<br /><br />    public void ApplyDispatchBehavior(OperationDescription operationDescription, System.ServiceModel.Dispatcher.DispatchOperation dispatchOperation)<br />    {<br />        IOperationInvoker defaultInvoker = dispatchOperation.Invoker;<br />        dispatchOperation.Invoker = new AuthenticationOperationInvoker(defaultInvoker);<br />    }<br /><br />    public void Validate(OperationDescription operationDescription)<br />    {}<br />}<br /></pre>In line 11 and 12 I fetch the default operation invoker and inject it into my custom which then replaces the operation invoker used by my webservice.<br /><br />That's it, now developers can just implement their webservices just as normal and add my custom attribute in order to augment the authorization process by calling the authorization service.<br /><pre class="brush:c#; highlight:[1]">[AuthorizedMethod]<br />[OperationBehavior(Impersonation = ImpersonationOption.Required)]<br />public string Hello(string message)<br />{<br />   //execute the custom webservice's business logic<br /><br />   return "hello";<br />}</pre>
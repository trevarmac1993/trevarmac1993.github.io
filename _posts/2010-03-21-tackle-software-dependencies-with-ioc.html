---
layout: post
title: "Tackle software dependencies with IoC and Dependency Injection"
date: 2010-03-21
comments: true
tags: [  Design Patterns, Best Practices, Spring ]
---

<p>Coupling between objects creates "dependency", which per se is not bad at all. You will always have some dependencies among your objects. It becomes bad when it increases abnormally since that will make maintenance a nightmare. So what you'll do is of course to reduce dependencies in your code as much as possible. This means you first have to identify potential sources of bad dependencies which could possibly be avoided.</p>



<h2>But how to identify them?&nbsp;</h2>
Well, you could just imagine a change to an object and count how many objects you'd have to adapt to your changes such that your program still runs smoothly. Another possibility is to rely on code metrics such as "Coupling between objects" from the CK OO metrics suite. That can give you quite a good overview of potential problems in your application.<br /><br />

<h2>What are some examples/sources of coupling/dependencies?</h2>
There is a distinction between <u>tight coupling</u>&nbsp;and <u>loose coupling</u>.<br /><ul><li><u>Inheritance (tight coupling)</u><br />Good OO designs will use inheritance heavily. Especially for exploiting polymorphism, nice hierarchies are created. But pay attention, inheritance is probably one of the strongest dependencies you can create, so it should just be used where it really makes sense: "For providing <u>special</u> behavior to an object". When you go down in the inheritance tree, objects should become more specialized, when you go up they should become more general. Inheritance shouldn't be used for instance to remove duplicate code. There is space for discussion here, however.<br />You may consider using composition/aggregation instead or take a look at the <a href="http://www.dofactory.com/Patterns/PatternDecorator.aspx">decorator pattern</a>. Another problem with inheritance is also that methods may be added and removed which may cause problems in large systems since you have to go and search where you should go and override the behavior.<br /><br /></li><li><u>Composition (loose coupling)<br /></u>Composition is already "better" in terms of coupling, since it creates loose coupling.<br /><br /><pre class="prettyprint">public class MyClass{<br />   private ISomeInterface anInterface;<br />}</pre>Note the usage of an interface here. I'll come back to that later. Composition creates loose coupling because when the interface changes you "just" need to adapt the dependent MyClass.<br /><br /></li><li><u>Instantiation (tight coupling)</u><br />Another very common form of dependency comes through instantiation.<br /><br /><pre class="prettyprint">public class MyClass{<br />   private PersistencyManager persistencyMan;<br /><br />   public MyClass(){<br />      this.persistencyMan = new PersistencyMan();<br />   }<br />}<br /></pre>Again, a dummy example that shows the dependency created by instantiating a new object of type PersistencyManager inside the class MyClass (it doesn't matter where).<br /><br /></li><li><u>Instantiation through Factories/Service locators (loose coupling)</u><br /><br /><pre class="prettyprint">public class MyClass{<br />   private PersistencyManager persistencyMan;<br /><br />   public MyClass(){<br />      ConfigFactory myFactory = ConfigFactory.getDefaultFactory();<br />      this.persistencyMan = myFactory.getPersistencyManager(); //or through configuration<br />   }<br />}<br /></pre>Here the dependency is also on the Factory. This code however creates loose coupling because the process of creating objects is "outsourced" to another object. MyClass doesn't know how the object is being build.<br /><br /></li><li><u>Static methods, attributes or Singletons (tight coupling)</u><br /><br /><pre class="prettyprint">public class MyClass{<br />   public void doSomeStuff(String userInput){<br />      ...<br />      MyHelper.helpMeOutWith(userInput);<br />      ...<br />   }<br />}<br /></pre>Here a dependency to a static "Helper" class is created which performs some logic.</li></ul>I guess I covered most of the dependencies that may occur in your code. Well, everything nice and fine, but how should one handle/avoid these dependencies?? The main aim is to...<br /><ul><li>minimize the dependencies in your system by aiming for loose couplings and to</li><li>depend on interfaces <b>only</b>&nbsp;rather than concrete classes.</li></ul>Remember, managing dependencies is the major challenge in designing good structured, large applications. If you're good in doing it, you'll have a nice time during maintenance.<br /><br />

<h2>The "magic" of an Inversion of Control (IoC) container and dependency injection</h2>
I'm not going to target to a specific technology now but rather I'd like to address the concept of dependency injection in general. Probably I'll focus on a specific example in a later post, let's see...<br /><br />While "dependency injection" is nearly self-explanatory from an understanding point of view, "inversion of control" sounds like an obscure concept. At least that was my first impression when I took a look at it a couple of years ago.&nbsp;Let's start from the beginning (I'll make it short; promise). I'll often briefly make a jump to unit testing since my feeling is that that's where dependencies are really uncovered.<br />So, what we want is to have loose coupling in our code, but somehow we will have to instantiate our objects in order to be able to work with them. According to the the list above we'd probably choose factories or service locators.<br /><pre class="prettyprint">public class MyCustomerService implements ICustomerService{<br />   private ICustomerDao customerDao;<br /><br />   public MyCustomerService(){<br />      this.customerDao = (ICustomerDao)MyDaoFactory.getInstance(CustomerDao.class); //one example of retrieval<br />      ...<br />   } <br /><br />   //returns true if validation and persistency succeeded, false otherwise;<br />   //this could be more sophisticated of course, returning a number of validation problems<br />   public boolean saveAndValidateCustomer(Customer aCustomer){<br />      //a set of validation instructions for your customer object<br />      ...<br /><br />      if(isAValidCustomer){<br />         customerDao.save(aCustomer);<br />         return true;<br />      }else{<br />         return false;<br />      }<br />   }<br />}<br /></pre>This may be a simple business logic class (in our service layer if we want so) which takes a customer, applies some validation on it and then delegates the persistency operation to the according DAO (<a href="http://en.wikipedia.org/wiki/Data_access_object">Data Access Object</a>). Note, we depend on interfaces here and the according dependency to the DAO object is created through a factory. This is the way you'd to it without IoC and DI (dependency injection). Now think about a unit test for the validation logic. What are the problems?? Well..we want to test the validation instructions inside the <code>saveAndValidateCustomer(...)</code> method but we <b>don't</b>&nbsp;want to test the persistency operation. That's out of scope of the unit test. But as you may have noticed, there is the <code>customerDao.save(...)</code> operation in it. We have to mock that out because we don't want to save something down or get annoying exceptions because some DB related stuff couldn't be loaded. Good we externalized the instantiation of the DAO into our factory and hopefully this factory depends on some <i>configuration file which in the end determines which interface gets instantiated with which concrete type</i>.<br /><pre class="prettyprint">public class CustomerServiceTest{<br />   private ICustomerService customerService;<br /><br />   public CustomerServiceTest(){<br />      MyDaoFactory.initializeWithConfig("mytestconfiguration.xml"); //test initialization<br />   }<br /><br />   @Before<br />   public void setUp(){<br />      this.customerService = new CustomerService();<br />   }<br /><br />   @After<br />   public void tearDown(){<br />      this.customerService = null;<br />   }<br /><br />   @Test<br />   public void testSaveAndValidateCustomer(){<br />      Customer aCustomer = new Customer();<br />      //initialize aCustomer by setting its properties to a valid state<br /><br />      boolean isValid = customerService.saveAndValidateCustomer(aCustomer);<br />      assertTrue("The customer object should be valid!", isValid);<br /><br />      //continue and set the customer to an invalid state and check again<br />   }<br />}<br /></pre>Ok, we should be safe now to execute the test. Note you have to initialize your factory with some test objects which point to empty "mock" DAOs where the save operation doesn't have any side effects.<br />This example was without IoC and due to the usage of a factory the process of mocking out the DAO wasn't too complex. However, don't underestimate it, you have to create an appropriate configuration file and you have to somehow adapt your unit tests to use the "test" factory. But on the other side consider the case where you would have instantiated your DAO manually using new.<br /><br />But still the example above needs a lot of logic just for retrieving the dependencies. IoC solves this. The concept goes down to the so-called hollywood principle: "Don't call me, I'll call you". Basically you don't retrieve you dependency but the dependency will be given, <b>injected</b>, to you at runtime. Thats why it's called <b>"inversion"</b>&nbsp;of control. It's not you that controls the setting of the instances directly, but the container does it.&nbsp;There are two different forms:<br /><b>Constructor injection</b><br /><pre class="prettyprint">public class MyCustomerService implements ICustomerService{<br />   private ICustomerDao customerDao;<br /><br />   public MyCustomerService(ICustomerDao customerDao){<br />      this.customerDao = customerDao;<br />      ...<br />   } <br /><br />   public boolean saveAndValidateCustomer(Customer aCustomer){<br />      ...<br />   }<br />}<br /></pre>or<br /><b>Setter injection</b><br /><pre class="prettyprint">public class MyCustomerService implements ICustomerService{<br />   private ICustomerDao customerDao;<br /><br />   public MyCustomerService(){<br />      ...<br />   } <br /><br />   public boolean saveAndValidateCustomer(Customer aCustomer){<br />      ...<br />   }<br /><br />   public void setCustomerDao(ICustomerDao customerDao){<br />      this.customerDao = customerDao;<br />   }<br />}<br /></pre>The resulting test case is really simple!<br /><pre class="prettyprint">public class CustomerServiceTest{<br />   private ICustomerService customerService;<br /><br />   @Before<br />   public void setUp(){<br />      //in the constructor injection case:<br />      this.customerService = new CustomerService(new MockCustomerDao());<br /><br />      //in the setter injection case:<br />      //this.customerService = new CustomerService();<br />      //this.customerService.setCustomerDao(new MockCustomerDao());<br />   }<br /><br />   @After<br />   public void tearDown(){<br />      this.customerService = null;<br />   }<br /><br />   @Test<br />   public void testSaveAndValidateCustomer(){<br />      //same as before<br />   }<br />}<br /></pre>Simple, isn't it? Unit testing becomes really simple in such cases. Normally when people claim their unit tests are too complex and therefore not done it is usually a sign they have too tightly coupled code and they therefore fail to mock out their dependencies.<br /><br />Now, the way your dependencies get injected into your classes depend on the specific technology of the&nbsp;<b>Inversion of Control container</b>&nbsp;you're using. Generally the IoC container controls the lifecycle of your objects. You can configure your dependencies either through configuration files (usually in xml format) or through annotations inside your classes. It's just a matter of personal preferences. As mentioned I'll not go into those details now, maybe that will follow in a later post. Below there are some reference to popular dependency injection libraries.

<h2>Dependency Injection libs</h2>
<a href="http://www.springsource.org/">Spring (Java)</a><br /><a href="http://code.google.com/p/google-guice/">Guice (Google, Java)</a><br /><a href="http://code.google.com/p/google-gin/">GInjector (Google, GWT, Java)</a><br /><a href="http://www.springframework.net/">Spring.net (.Net)</a><br /><a href="http://www.codeplex.com/unity">Unity (.Net)</a><br /><ul><ul></ul></ul>
---
layout: post
title: "GWT meets Spring"
date: 2009-09-29
comments: true
tags: [  JavaScript, GWT, Java, Google, Spring, Web dev ]
---

<a href="http://code.google.com/webtoolkit/">GWT</a> is quite evolving recently. There are a couple of reasons for that:<br /><ul><a href="http://www.springsource.org/sites/all/themes/zen/framework/logo.png" imageanchor="1" style="clear: right; float: right; margin-bottom: 1em; margin-left: 1em;"><img border="0" src="http://www.springsource.org/sites/all/themes/zen/framework/logo.png" /></a><a href="http://code.google.com/webtoolkit/images/gwt-logo.png" imageanchor="1" style="clear: right; float: right; margin-bottom: 1em; margin-left: 1em;"><img border="0" src="http://code.google.com/webtoolkit/images/gwt-logo.png" /></a><li><u>Coding apps like Gmail and Google Wave</u><br />We all appreciate the speed of the Gmail UI. It's just like operating on a local client. Moreover the coming (already popular) Google Wave has been build using GWT.<br /><br /></li><li><u>Cross-browser compatibility</u><br />The produced outcome by GWT is pure JavaScript, optimized for performance and cross-browser compatibility. The major advantage: there is no need for installing a runtime, plugin or whatever. It's just plain JavaScript!<br /><br /></li><li><u>IDE support and Hosting solutions</u><br />The new <a href="http://code.google.com/eclipse/">Google Plugin for Eclipse</a> makes it easy to develop GWT apps. Debugging, hosted mode browsing without the need of a deployment makes it feel like developing desktop clients.<br />Moreover a 1-click deploy to <a href="http://appengine.appspot.com/">Appengine</a> is provided which can be used as the hosting solution with Google-like DB already integrated.</li></ul>&nbsp;For making this enterprise ready however you probably would like to use some more powerful tools especially at the server-side. You know <a href="http://www.springsource.org/">Spring</a> :) ? If not, you should get in contact with it.<br /><br />What I tried to do is to integrate GWT with Spring and Google Appengine. I tried to do that already about 2 years ago and succeeded but unfortunately I didn't have the time to continue. Meanwhile GWT has evolved and there is a lot of support available on the web and even on the GWT Googlecode hosting for integrating both (just google for it).<br /><br />The central element for connecting both is to have the <a href="http://code.google.com/p/google-web-toolkit-incubator/wiki/IntegratingWithSpring">GWTController</a> which accepts the incoming HTTP requests, decodes the Google-RPC payload and invokes the correct implementation of the server-side service, catches the response, encodes everything and sends it back.<br />So I configured the standard GreetingService demo and launched my GWT app and see there..<br /><pre class="code">WARNING: Nested in org.springframework.web.util.NestedServletException: Request processing failed; nested exception is java.lang.NullPointerException:<br />java.lang.NullPointerException<br />    at javax.servlet.GenericServlet.getServletContext(GenericServlet.java:163)<br />    at com.google.gwt.user.server.rpc.RemoteServiceServlet.doUnexpectedFailure(RemoteServiceServlet.java:284)<br />    at com.google.gwt.user.server.rpc.RemoteServiceServlet.doPost(RemoteServiceServlet.java:99)<br />    at com.myapp.demo.server.GWTController.handleRequest(GWTController.java:51)<br />    at org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter.handle(SimpleControllerHandlerAdapter.java:48)<br />    at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:781)<br />    at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:726)<br />    at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:636)<br />    at org.springframework.web.servlet.FrameworkServlet.doPost(FrameworkServlet.java:556)<br />    at javax.servlet.http.HttpServlet.service(HttpServlet.java:713)<br />    at javax.servlet.http.HttpServlet.service(HttpServlet.java:806)<br />    at org.mortbay.jetty.servlet.ServletHolder.handle(ServletHolder.java:487)<br />    at org.mortbay.jetty.servlet.ServletHandler$CachedChain.doFilter(ServletHandler.java:1093)<br />    at com.google.apphosting.utils.servlet.TransactionCleanupFilter.doFilter(TransactionCleanupFilter.java:43)<br />    at org.mortbay.jetty.servlet.ServletHandler$CachedChain.doFilter(ServletHandler.java:1084)<br />    at com.google.appengine.tools.development.StaticFileFilter.doFilter(StaticFileFilter.java:121)<br />    at org.mortbay.jetty.servlet.ServletHandler$CachedChain.doFilter(ServletHandler.java:1084)<br /></pre>A nice NullPointerException when the "javax.servlet.GenericServlet.getServletContext()" gets invoked. Perfekt, was not even my code. I searched a while for a solution, when some hints on the web lead me into the right direction. For avoiding this problem the GWTController has to be made "context aware". Basically it has to get the ServletContext injected. By doing so, the GWTController code should look like this:<br /><pre class="prettyprint">public class GWTController extends RemoteServiceServlet implements Controller, <b>ServletContextAware</b> {<br /> // Instance fields<br /> private RemoteService remoteService;<br /> private Class remoteServiceClass;<br /> <b>private ServletContext servletContext;</b><br /><br /> // Public methods<br /> /**<br />  * Implements Spring Controller interface method.<br />  * <br />  * Call GWT's RemoteService doPost() method and return null.<br />  * <br />  * @param request<br />  *            current HTTP request<br />  * @param response<br />  *            current HTTP response<br />  * @return a ModelAndView to render, or null if handled directly<br />  * @throws Exception<br />  *             in case of errors<br />  */<br /> public ModelAndView handleRequest(HttpServletRequest request,<br />   HttpServletResponse response) throws Exception {<br />  doPost(request, response);<br />  return null; // response handled by GWT RPC over XmlHttpRequest<br /> }<br /><br /> /**<br />  * Process the RPC request encoded into the payload string and return a<br />  * string that encodes either the method return or an exception thrown by<br />  * it.<br />  */<br /> public String processCall(String payload) throws SerializationException {<br />  try {<br />   RPCRequest rpcRequest = RPC.decodeRequest(payload,<br />     this.remoteServiceClass);<br /><br />   // delegate work to the spring injected service<br />   return RPC.invokeAndEncodeResponse(this.remoteService, rpcRequest<br />     .getMethod(), rpcRequest.getParameters());<br />  } catch (IncompatibleRemoteServiceException e) {<br />   return RPC.encodeResponseForFailure(null, e);<br />  }<br /> }<br /><br /> /**<br />  * Setter for Spring injection of the GWT RemoteService object.<br />  * <br />  * @param RemoteService<br />  *            the GWT RemoteService implementation that will be delegated to<br />  *            by the {@code GWTController}.<br />  */<br /> public void setRemoteService(RemoteService remoteService) {<br />  this.remoteService = remoteService;<br />  this.remoteServiceClass = this.remoteService.getClass();<br /> }<br /> <br /> @Override<br />        public ServletContext <b>getServletContext()</b> {<br />           return servletContext;<br />        }<br /><br />        public void <b>setServletContext(ServletContext servletContext)</b> {<br />           this.servletContext = servletContext;<br />        }<br /><br />}</pre>In this way the ServletContext gets fetched from here. Note, if your service implementations classes do also need to use the ServletContext, you have to basically do the same thing: implementing the ServletContextAware interface and overriding the corresponding methods. Then you should be done and everything should just work seamlessly :) Just comment if you have any questions about it.
---
layout: post
title: "The power and simplicity of the Command pattern"
date: 2009-12-10
comments: true
tags: [  Design Patterns, Best Practices, Software Design ]
---

<p>Never thought of how to implement an "undo" function? Not that easy, huh? People in our architecture class today came up with quite creative solutions: two separate stacks storing operations, versioning of the object to go back etc... All quite complex. Well, I've thought about that already about a year ago, so it was quite easy for me and there you actually see how simple such a task becomes if you know the right pattern (I'll come to it immediately).</p>

The key is actually to encapsulate the operation and the object the operation acts on. If you encapsulate that within an object you're already pretty much done. Every time you perform an operation you create such an object encapsulating that operation.<br /><br /><img src="http://yuml.me/diagram/scruffy;/class/[ICommand%20|%20execute()]" /><br /><br />If you knew about it already...yes, it's the Command pattern :) . Now the interface above is the standard implementation, but adding undo is not a major difficulty. You can either add the method to the ICommand interface or create another abstract class/interface UndoableCommand using ICommand. Take for instance the operation "make bold" of a word within a document. Applying the Command pattern and adapting it for undo and redo functions is quite simple<br /><br /><img src="http://yuml.me/diagram/scruffy;/class/[ICommand%20|%20undo();%20execute();%20redo()]^-[BoldCommand],%20[BoldCommand]&lt;&gt;-&gt;[Word]" /><br /><br />For each concrete command you implement the interface. So an example implementation of such a BoldCommand could look like<br /><pre class="prettyprint">public class BoldCommand implements ICommand{<br />   private Word aWord;<br /><br />   public BoldCommand(Word aWord){<br />      this.aWord = aWord;<br />   }<br /><br />   public void execute(){<br />      //call some appropriate object that knows how to perform<br />      //the action, i.e.<br />      aWord.setBold(true);   <br />   }<br /><br />   public void undo(){<br />      //undoing is easy since we know here what we did previously and<br />      //we have the reference to the object we acted upon<br />      aWord.setBold(false);<br />   }<br /><br />   public void redo(){<br />      execute();<br />   }<br />}<br /></pre>I guess this should look now pretty obvious to you. Of course this is just a simple code for demonstrating the idea. You need some more sophisticated structures that take care of these command objects. For the undo/redo you'd probably have some list that tracks all of these objects, removes old ones etc...<br />If you programmed already for the Eclipse platform, you probably came across the IAction interface and Action classes. Well that's one implementation of such a command pattern. They use it quite heavily there.<br /><br />Now that you know the pattern, think about the solution you came up with previously (2 stacks, operations, undo operations etc..). Quite complicated :) I like this example because I think this example of the undo/redo functionality explains quite clearly the improvement of your code if you know the right - and obviously suitable - pattern.
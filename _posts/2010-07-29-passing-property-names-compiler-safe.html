---
layout: post
title: Passing Property Names the "compiler-safe" Way
date: 2010-07-29
comments: true
tags: [  Best Practices, C#, .Net ]
---

<p>A common bad practice which I often find when browsing through code is to see people directly hard-code strings in their source code. I've also proposed some refactorings in <a href="http://blog.js-development.com/2009/05/string-enumerations-in-c.html">some </a>of <a href="http://blog.js-development.com/2010/01/comments-smell-replace-them-with-more.html">my previous posts</a>. Today I'd like to blog about a similar issue which targets the issue of <b>object property referencing</b> within code.</p>

I guess most of us already had the case where you give a property of your entity like <br /><pre class="prettyprint">SomeHelper.Validate(entityObject, "somePropertyName", value);<br />SomeHelper.Validate(entityObject, "someOtherPropertyName", value);</pre>This "strange" assignment because SetProperty takes objects in a generic way and validates the specified property. Note, this is not real-world code, so don't be scared :) , but it may arise in similar ways throughout your code-base.<br />Another use case I was currently experiencing and which was the reason for writing this blog post is when announcing a problem about some property to the system user (i.e. in a log). In such a case you'd probably write<br /><pre class="prettyprint">MyLogger.LogProblem("SomePropertyName", "Some message from a resource file");</pre><br />So what's the problem with such code?<br /><ul><li><b>No compile-time-checking</b><b>!</b>&nbsp;Changing the property name of your object, won't give you any error during compile time but you may experience nice errors when the system is being used. Well ok, ReSharper does a nice job in also including such strings in refactorings, but still.<br />These kind of bugs are heavy, since you may have difficulties in spotting them.</li><li>It is <b>cumbersome&nbsp;to type</b> and code because you have to remember the exact name of the property without any kind of Intellisense support.</li></ul>These issues can be solved by using a nice Linq construct.<br /><pre class="prettyprint">public static void LogProblem&lt;T&gt;(Expression&lt;Func&lt;T&gt;&gt; propertyExpression, string message)<br />{<br />    string propertyName = GetPropertyName(propertyExpression);<br />    if (propertyName == null)<br />        throw new NullReferenceException("The name of the property couldn't be retrieved!");<br /><br />    LogEntry logEntry = new LogEntry()<br />    {<br />        Fieldname = propertyName,<br />        MessageDescription = String.Format(message, propertyName)<br />    };<br /><br />    logEntries.Add(logEntry);<br />}<br /><br />public static string GetPropertyName&lt;T&gt;(Expression&lt;Func&lt;T&gt;&gt; expression)<br />{<br />    MemberExpression body = (MemberExpression)expression.Body;<br />    return body.Member.Name;<br />}</pre>This can then be used very nicely by rewriting the logging instruction I mentioned before like this<br /><pre class="prettyprint">MyLogger.LogProblem(() =&gt; myObjInstance.SomePropertyName, "Some message from a resource file");<br /></pre>Voil√°, you have a compile-time, fully intellisense supported logging method now. The only thing I don't really like is the somehow strange-looking declaration of the property name by having to use <code>() =&gt;</code>&nbsp;...
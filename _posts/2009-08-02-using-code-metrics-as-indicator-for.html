---
layout: post
title: "Using code metrics as indicator for code refactoring"
date: 2009-08-02
comments: true
tags: [  Best Practices, Software Design ]
---

Developing software is not just hacking in a solution, but to develop simple, well structured and therefore maintainable constructs. There are a couple of design guidelines that one should follow (<a href="http://projects.js-development.com/best-practices/programming-commandments-3">some of them are here</a>) to achieve this. However often special time pressure or older code may nevertheless get messy and complex. That's where <a href="http://en.wikipedia.org/wiki/Refactoring">refactoring</a> comes in. Usually the best advice is to refactor immediately once you find <a href="http://en.wikipedia.org/wiki/Code_smell">"smelling" code</a> (as the XP guys call it). Don't&nbsp; postpone it to a later point, you won't come back.<br /><br />What I found quite useful in finding points for refactoring is to use code metrics. Code metrics usually appear when software quality management comes into play and there exist really a bunch of different (more and less discussed) metrics. From my point of view the most interesting is the <i>Cyclomatic Complexity</i> measure and the following two, "<i>Coupling between objects (CBO)</i>" and "<i>Lack of cohesion in methods (LCOM)</i>" from the CK suite (Chidamber and Kemerer OO measures).<br />Why do I point out especially these three? Well, because they are easily understandable and they point out problems in the design of your code, usually at class level. For instance:<br /><ul><li><u>Cyclomatic Complexity</u><br />It measures the complexity of parts of your code and is calculated by counting the <i>number of decision points + 1</i>.<br /><br /><pre class="prettyprint">public bool checkSomething(int x){<br />   bool result = false;<br />   if(x &lt; 10)<br />      result = true;<br />   else<br />      result = false;<br /><br />   return result;<br />}<br /></pre>This extremely simple piece of code has CC = 2 because we have one decision point (the if). But just changing the code in this way...<br /><br /><pre class="prettyprint">public bool checkSomething(int x){<br />   bool result = false;<br />   if(x &lt; 10){<br />      if(x &gt; 4)<br />         result = true;<br />      else<br />         result = false;<br />   }else{<br />      result = false;<br />   }<br /><br />   return result;<br />}<br /></pre>...increases the cyclomatic complexity already to 3 etc. And you see, it is already more difficult to read because you have to check carefully which kind of x values would now go through the first branch and result in a "true" value, which in a "false" value and which would immediately skip the first branch and result in a "false" value. Normally a value below CC=10 is considered to be acceptable, although I usually try to keep it below 6-8. Imagine however how a code would look with CC = 20 and higher. And how hard it would be to debug it.          </li></ul>Of course you don't have to calculate these things by hand :) . There exists tools for nearly every IDE. In Visual Studio Team system for instance you can calculate such metrics by using the context menu in the Solution Explorer.<br /><div class="separator" style="clear: both; text-align: center;"><a href="http://1.bp.blogspot.com/_tF6XjsUy87k/Sha7QbpjHwI/AAAAAAAACUM/5jIK1aDOFXs/s1600-h/codeMetricsCalculateVisualStudio.jpg" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://1.bp.blogspot.com/_tF6XjsUy87k/Sha7QbpjHwI/AAAAAAAACUM/5jIK1aDOFXs/s320/codeMetricsCalculateVisualStudio.jpg" /></a></div><br />The results will then be displayed in the Code Metrics Results view. The MSDN Code Analysis blog explains the Visual Studio code metrics view and its calculated metrics in more detail <a href="http://blogs.msdn.com/fxcop/archive/2007/10/03/new-for-visual-studio-2008-code-metrics.aspx">here</a>.
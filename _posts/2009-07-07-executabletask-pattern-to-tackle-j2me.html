---
layout: post
title: "ExecutableTask pattern to tackle J2ME multithreading"
date: 2009-07-07
comments: true
tags: [  Java, J2ME, Design Patterns, mobile dev ]
---

Programming on the mobile device is quite different to more common environments like web or client-server desktop applications. Although mobile devices become always more and more powerful (i.e. like iPhone's OS and Android) one has still to consider issues like limited memory and I/O devices. Take for instance a look <a href="http://d.android.com/guide/practices/design/performance.html">at the Android best practices</a>.<br /><br />When programming on J2ME for the CLDC these kind of things are key issues that have to be considered. There are a <a href="http://blog.js-development.com/2009/04/best-practices-challenge-of-designing.html">number of best practices</a> around, one being the advise to place "heavy" computations in a separate thread in order to not block the J2ME system thread. That implies that you'll have to deal with a lot of threads that need to be handled. Keeping track of the execution of these threads can often become quite complicated.<br />Therefore - in my last <a href="http://aroundj2me.googlecode.com/">J2ME project</a> - I've created what I called the "Executable Task pattern" in order to handle these situations more easily. Actually it's not a pattern per s√© but more like a variant of an Observer and Command pattern. A similar approach is used for defining the Java Swing event handlers for button clicks etc.<br /><br />The "Executable Task" is composed of two objects.<br /><pre class="prettyprint">public abstract class TaskProcessListener {<br /> /**<br />  * Gets invoked when the {@link ExecutableTask} finishes processing<br />  * @param result the resulting object from the computation<br />  */<br /> public abstract void onSuccess(Object result);<br /> <br /> /**<br />  * Gets invoked when an error occurs during processing<br />  * @param status the status message containing information about the error<br />  */<br /> public abstract void onError(String status);<br />}</pre><br />This is the abstract class that defines the abstract methods that <b>have</b> to be implemented. This "TaskProcessListener" is used by the 2nd class, the "ExecutableTask".<br /><pre class="prettyprint">public abstract class ExecutableTask implements Runnable {<br /> protected TaskProcessListener listener;<br /> <br /> public ExecutableTask(){ <br /> }<br /> <br /> public void run(){<br />  //initializations prior the execution of the task itself<br /> }<br /> <br /> public ExecutableTask(TaskProcessListener listener){ <br />  this.listener = listener;<br /> }<br /><br /> protected void notifyTaskFinished(Object result){<br />  this.listener.onSuccess(result);<br /> }<br /> <br /> protected void notifyError(String statusMessage){<br />  this.listener.onError(statusMessage);<br /> }<br /><br /> public TaskProcessListener getListener() {<br />  return listener;<br /> }<br /><br /> public void setListener(TaskProcessListener listener) {<br />  this.listener = listener;<br /> }<br />}<br /></pre><br />This is the main class, but still quite simple, isn't it? There isn't much to explain here, just a couple of class members and getters and setters. Note however that the class is declared abstract and that it inherits from "Runnable", meaning that it can be executed within a thread.<br />Now comes the interesting part. When you actually have an operation that needs to run within his own thread (i.e. a network access) you inherit from the ExecutableTask class instead of Runnable as you would usually do. Consider for instance the simple code for <a href="http://blog.js-development.com/2009/06/midlet-for-downloading-image-from-web.html">downloading an Image from the web by using an HttpConnection which I've posted a couple of days ago</a>. You would code that as follows:<br /><pre class="prettyprint">import javax.microedition.io.Connector;<br />import javax.microedition.io.HttpConnection;<br />import javax.microedition.lcdui.Image;<br /><br />public class ImageLoaderTask extends <b>ExecutableTask</b> {<br /> private String imageUrl;<br /> <br /> public ImageLoaderTask(String imageUrl){<br />  this.imageUrl = imageUrl;<br /> }<br /><br /> public void run() {<br />  HttpConnection connection;<br />  try {<br />   connection = (HttpConnection) Connector.open(this.imageUrl);<br />   connection.setRequestMethod(HttpConnection.GET);<br />   <br />   Image loadedImg = Image.createImage(connection.openInputStream());<br />   <b>notifyTaskFinished(loadedImg);</b><br />  } catch (Exception e) {<br />   <b>notifyError(e.getMessage());</b><br />  }<br /> }<br /> <br />}</pre><br />The instantiation of the ImageLoaderTask is then done by writing...<br /><pre class="prettyprint">ImageLoaderTask imageLoadTask = new ImageLoaderTask(imageUrlField.getString());<br />imageLoadTask.setListener(new TaskProcessListener(){<br /><br /> public void onError(String status) {<br />  //alert the user about the problem<br /> }<br /><br /> public void onSuccess(Object result) {<br />  //do something with the result<br /> }<br /> <br />});</pre>...again really simple. You can use the "onError(...)" for notifying the user about some problem during the execution of the task and the "onSuccess(...)" for processing a successful outcome.<br />The following Form demonstrates the usage of the ImageLoaderTask: <br /><pre class="prettyprint">import javax.microedition.lcdui.Alert;<br />import javax.microedition.lcdui.AlertType;<br />import javax.microedition.lcdui.Command;<br />import javax.microedition.lcdui.CommandListener;<br />import javax.microedition.lcdui.Display;<br />import javax.microedition.lcdui.Displayable;<br />import javax.microedition.lcdui.Form;<br />import javax.microedition.lcdui.Image;<br />import javax.microedition.lcdui.TextField;<br />import javax.microedition.lcdui.Ticker;<br /><br />public class ImageForm extends Form implements CommandListener {<br /> private TextField imageUrlField;<br /> private Command loadImage;<br /> private Display display;<br /><br /> public ImageForm(Display display) {<br />  super("Image Viewer");<br />  init();<br />  this.display = display;<br /> }<br /><br /> private void init() {<br />  imageUrlField = new TextField("Image URL", "", 999, TextField.URL);<br />  this.append(imageUrlField);<br /><br />  loadImage = new Command("Load Image", Command.SCREEN, 1);<br />  this.addCommand(loadImage);<br /><br />  this.setCommandListener(this);<br /> }<br /><br /> public void showLoadedImage(Image image) {<br />  if(this.size() == 2)<br />   this.delete(1);<br />  this.imageUrlField.setString("");<br />  this.append(image);<br />  this.setTicker(null);<br /> }<br /><br /> public void commandAction(Command c, Displayable d) {<br />  if (c == loadImage) {<br />   downloadImage();<br />  }<br /> }<br /> <br /> private void showMessage(String message){<br />  this.setTicker(new Ticker(message));<br /> }<br /> <br /> private void stopMessage(){<br />  this.setTicker(null);<br /> }<br /> <br /> private void downloadImage(){<br />  showMessage("loading image");<br />  <br />  <b>ImageLoaderTask imageLoadTask = new ImageLoaderTask(imageUrlField.getString());</b><br />  imageLoadTask.setListener(new TaskProcessListener(){<br />  <br />   public void onError(String status) {<br />    stopMessage();<br />    <br />    //show an alert notifying about the problem<br />    Alert alert = new Alert("Error", "Error when loading image " + status, null, AlertType.ERROR);<br />    alert.setTimeout(Alert.FOREVER);<br />    display.setCurrent(alert);<br />   }<br />  <br />   public void onSuccess(Object result) {<br />    showLoadedImage((Image)result);<br />   }<br />   <br />  });<br />  <br />  Thread t = new Thread(imageLoadTask);<br />  t.start();<br /> }<br /><br />}</pre>
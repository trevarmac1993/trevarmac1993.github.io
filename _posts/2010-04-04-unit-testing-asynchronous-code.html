---
layout: post
title: "Unit testing asynchronous code"
date: 2010-04-04
comments: true
tags: [  Java, testing, Software Design ]
---

<p>Today I wrote on a first prototype for my current thesis research. I started coding just ahead however - at the same time - trying to find a good design which has a high potential to be reused for the final system. <a href="http://blog.js-development.com/2010/03/tackle-software-dependencies-with-ioc.html">Modularity, decoupling</a> etc. are main goals of course and since the prototype interacts with the Bluetooth API one of my main aims was to try to separate the logic dealing with it as much as possible from the rest of the application. This separation gives several benefits: for accessing the device's bluetooth stack, access to native libraries is necessary. So depending on whether your app runs on Linux, Windows or OSX you may have to rely on different libraries.</p>

Again, going with TDD you're best served. And actually this is where the Test-Driven-<b>Design</b>&nbsp;(instead of the commonly used "development") comes to play. By starting with your test and by thinking on how to test your logic in the simplest way, you're most likely to come out with a testable and consequently nicely decoupled system. But when you have asynchronous code, things get messy again. How to you test asynchronous code?? Assume the following (I'm using Java here, but could refer to it with C# in the same way)<br /><pre class="prettyprint">@Test<br />public void testSomeLogic(){<br />   assert(...); //assert some state<br /><br />   myObj.executeSomething(); //assume this is executed asynchronously<br /><br />   assert(...); //assert the result of the execution<br />}<br /></pre>Now for sure you agree that the 2nd assert which should check the result of the execution of "executeSomething()" will probably be called before the asynchronous code executed inside "executeSomething()" finishes processing. Consequently the test will always fail.<br /><br />Browsing the web brought me through some interesting approaches to handle this problem. &nbsp;The best way of course is to try to mock out this asynchronous stuff as much as possible s.t. you can avoid having it in your test cases. But often (as also in my situation) this wasn't just possible. So a solution is basically to wait for the async call to finish. How is this done?<br />Let's outline my situation more clearly. I have a controller class which has the following<br /><pre class="prettyprint">public class BluetoothDevicesController{<br />   private IBluetoothDeviceDiscoveryAgent discoveryAgent;<br />   ...<br /><br />   public BluetoothDevicesController(IBluetoothDeviceDiscoveryAgent discoveryAgent){<br />      this.discoveryAgent = discoveryAgent;<br />   }<br /><br />   public void startDiscovery(){<br />      Timer timer = new Timer();<br />      timer.schedule((TimerTask)discoveryAgent, 0, 5000); //reruns the thread every 5 secs<br />   }<br /><br />   ...<br />}<br /></pre>This is more or less the outline of the controller which is subject to my test. The <code>startDiscovery()</code> method starts the asynchronous execution by rescheduling the device discovery every 5 seconds.<br /><div class="notebox info"><b>Note:</b> the class doing the "low-level" Bluetooth interactions is injected in the constructor and separated through an appropriate interface. The controller is not aware of the Bluetooth interactions.</div>The separation with an interface allows the creation of a mock which can be used in the unit test to avoid the Bluetooth logic. So let's come to the implementation of the Mock + test.<br /><pre class="prettyprint">public class <b>Mock</b>BluetoothDeviceDiscoveryAgent extends TimerTask implements IBluetoothdeviceDiscoveryAgent{<br />   ...<br /><br />   public void run(){<br />      eventListener.onDeviceDiscoveryFinished(devices);<br />      synchronized(this){<br />         notifyAll();<br />      }<br />   }<br />}<br /></pre>The test case has the following structure<br /><pre class="prettyprint">public class BluetoothDevicesControllerTest{<br />   ...<br />   @Test<br />   public void testDevicesDiscovery(){<br />      assert(...) //initial check<br /><br />      deviceDiscoveryController.startDiscovery(); //the async method<br /><br />      synchronized(mockDiscoveryAgent){<br />         mockDiscoveryAgent.wait(2000); //set a timeout of 2 seconds<br />      }<br /><br />      assert(...) //final check<br />   }<br />   ...<br />}<br /></pre>Some comments: The <code>notifyAll()</code> in the mock object notifies all threads which went into sleep previously to wake up. The one with highest priority will continue processing. The synchronized block is needed since notifyAll can just be called within it.<br />The according test case does the opposite. It uses the synchronized to go into the wait state and sleeps for a timeout of 2 seconds. In the mean time, if the notifyAll gets called, the test case continues its work.
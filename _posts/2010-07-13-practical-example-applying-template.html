---
layout: post
title: "Practical example: Applying the Template Method design pattern"
date: 2010-07-13
comments: true
tags: [  Design Patterns, C#, refactoring, .Net ]
reposts: ["http://www.dotnetcodegeeks.com/2012/01/template-method-design-pattern.html"]
---

<p>As I already mentioned in <a href="http://blog.js-development.com/2010/07/refactoring-for-sake-of-compactness-and.html">my previous post</a> I'm currently doing domain objects to XSD generated object mapping. Monotonic, exactly, but I'm approaching the end of the work.<br />Still, when doing such annoying work, I'm continuously striving to reduce the amount of work by trying to find smarter, faster, more concise ways for doing this tedious work (in order to finish earlier ;) ). Usually after a couple of hours common patterns/repetitions emerge as I learn the structure of the underlying XSD. <a href="http://blog.js-development.com/2010/07/refactoring-for-sake-of-compactness-and.html">Refactorings</a>&nbsp;then usually help to proceed faster.</p>

A design pattern which I found to fit nicely when doing such object mapping work is the <a href="http://en.wikipedia.org/wiki/Template_method_pattern">Template Method design pattern</a>.<br /><blockquote>A template method defines the&nbsp;<a class="mw-redirect" href="http://en.wikipedia.org/wiki/Program_skeleton" style="background-attachment: initial; background-clip: initial; background-color: initial; background-image: none; background-origin: initial;" title="Program skeleton"><span class="Apple-style-span" style="color: black;">program skeleton</span></a>&nbsp;of an&nbsp;<a href="http://en.wikipedia.org/wiki/Algorithm" style="background-attachment: initial; background-clip: initial; background-color: initial; background-image: none; background-origin: initial;" title="Algorithm"><span class="Apple-style-span" style="color: black;">algorithm</span></a>. One or more of the algorithm steps are able to be overridden by subclasses to provide their own concrete implementation. This allows differing behaviors while ensuring that the overarching algorithm is still followed.<br /><span class="Apple-style-span" style="font-size: small;">Source: <a href="http://en.wikipedia.org/wiki/Template_method_pattern">Wikipedia</a></span></blockquote>In fact, the most interesting part when doing this kind of mapping work is to define an appropriate program skeleton for outlining the basic structure and here is where I used the Template Method pattern.<br />The data flow is from the application's domain model to the XSD generated objects. Basically there is some input (one or potentially more domain objects) which produces the desired output (exactly one XSD generated object). These objects have then to be assembled properly before being serialized to the final XML output. Frankly, just basic serialization work.<br /><a name='more'></a><br /><br />So after a while the common repetitive work which emerged remained stable at a structure similar to<br /><pre class="prettyprint">public class SomeDomainObjMapper<br />{<br />   private SomeDomainObj domainObj;<br />   private SomeOtherDomainObj otherDomainObj;<br />   private List&lt;LogType&gt; logs; //for collecting log entries about problems during mappings<br /><br />   public SomeDomainObjMapper(SomeDomainObj domainObj, SomeOtherDomainObj otherDomainObj)<br />   {<br />      this.domainObj = domainObj;<br />      this.otherDomainObj = otherDomainObj;<br />   }<br /><br />   public XSDGeneratedDomainObj Map(out List&lt;LogType&gt; mappingLogs)<br />   {<br />      XSDGeneratedDomainObj convertedType = new XSDGeneratedDomainObj();<br /><br />      convertedType.SomeProperty = domainObj.SomeOtherProperty;<br />      ...<br />      //more complex mappings etc..<br /><br />      return convertedType;<br />   }<br /><br />   ...<br />}<br /></pre>I guess you already identified the common pattern. There are always one or more objects from the apps domain model (which we don't know in advance) and <b>one</b>&nbsp;XSD generated object to which data will be mapped and which will be returned. The mapping will be done by the Map(...) method which is specific to each Mapper.<br /><br />So a generalized structure could look like<br /><pre class="prettyprint">public abstract class BaseMapper&lt;TItem&gt; where TItem: new()<br />{<br />   protected List&lt;LogType&gt; logEntries;<br /><br />   public BaseMapper()<br />   {<br />      //initialization stuff<br />   }<br /><br />   //will be called from "outside", the template method<br />   public TItem Map(out List&lt;LogType&gt; logs)<br />   {<br />      TItem convertedType = new TItem();<br /><br />      //call to the specific mapping method<br />      Map();<br /><br />      //assign the logs to be returned<br />      logs = logEntries; <br />      return convertedType;<br />   }<br />   <br />   protected abstract void Map();<br /><br />   ...<br />}<br /></pre>You see? This BaseMapper gives the basic structure, <b>the skeleton</b>. The specific mapping class will then look as follows:<br /><pre class="prettyprint">public class SomeDomainObjMapper : BaseMapper&lt;XSDGeneratedDomainObj&gt;<br />{<br />   private SomeDomainObj domainObj;<br />   private SomeOtherDomainObj otherDomainObj;<br />   private List&lt;LogType&gt; logs; //for collecting log entries about problems during mappings<br /><br />   public SomeDomainObjMapper(SomeDomainObj domainObj, SomeOtherDomainObj otherDomainObj)<br />   {<br />      this.domainObj = domainObj;<br />      this.otherDomainObj = otherDomainObj;<br />   }<br /><br />   protected void Map()<br />   {<br />      convertedType.SomeProperty = domainObj.SomeOtherProperty;<br />      ...<br />      //more complex mappings etc..<br />   }<br /><br />   ...<br />}<br /></pre>The Map() method will now <b>just</b>&nbsp;contain the mapping and nothing else. The logic of how it is called and what is done before/after mapping resides in the <b>template</b>.
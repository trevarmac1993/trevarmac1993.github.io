---
layout: post
title: "Do I Really Need to Test This??"
date: 2010-08-03
comments: true
tags: [ Best Practices, testing ]
---

Yes! Let's start straight of with an example. Consider I have my service (business) class <code>SourceCodeItemService</code> and an according <code>SourceCodeItemDao</code> class in my nicely layered app and there is the method <code>removeSourceCodeItem(SourceCodeItem)</code> with the following content<br /><pre class="prettyprint">public class SourceCodeItemService implements ISourceCodeItemService{<br />   ...<br />   private ISourceCodeItemDao sourceCodeItemDao; //this will be injected at runtime<br /><br />   public void removeSourceCodeItem(SourceCodeItem itemToRemove){<br />      sourceCodeItemDao.delete(itemToRemove);<br />   }<br />   ...<br />}<br /></pre>Note, the method really only has one line and all the logic it executes is to delegate the command to the underlying data access object class. Many devs, especially "unit testing newbies" would be tempted to not test this method because "it hasn't really logic inside but just delegates". Indeed, to some degree this is true, but note that the <code>SourceCodeItemService</code> class is just in its beginnings.<br /><div class="notebox info"><b>Remember</b>, a test should not only <b>verify the correctness of the current behavior</b>&nbsp;but also <b>preserve that behavior in case of future changes</b>.</div>I want to be sure that if other devs modify my remove method, it will still work the way I expected it to do!<br /><br />Said that, let's take a look on how the actual unit test for such a method would look like. First of all, what do we want to verify? We want to test the logic of the SourceCodeItemService.removeSourceCodeItem(...) in <b>isolation</b>. In a test-first approach, we know that our service class will use a DAO for persisting the delete operation. So as there will be no other planned behavior for the remove method we want to assure that dao is being called correctly, nothing more, nothing less.<br /><pre class="prettyprint">public class SourceCodeItemServiceTest{<br /><br />   //setup stuff etc..<br /><br />   @Test<br />   public void testRemoveSourceCodeItem(){<br />      //the dummy item to be deleted<br />      SourceCodeItem item = new SourceCodeItem(...);<br />      verify(mockSourceCodeItemDao).delete(item);<br /><br />      sourceCodeItemService.removeSourceCodeItem(item);<br />   }<br />}<br /></pre>That's it. I'm using <a href="http://mockito.org/">Mockito</a> here, a mocking library for Java. The <code>verify</code> call in the middle is a call to the Mockito library which assures the method delete of the DAO is correctly called with the object I'm passing. So there is a further check that the correct object is being given to the DAO. However you could easily also achieve the same behavior without a mocking framework, although I highly suggest you to adopt one which suits your needs.<br /><br />So to conclude, a question that may arise when you look at this is "how I did verify whether the item has actually been deleted". To be honest, I didn't! But this is not the scope of the unit test of this service class here but rather of a possible (integration) test of the <code>SourceCodeItemDao</code> class :)
---
layout: post
title: "Why factories with configuration files are better for decoupling but still a testability killer"
date: 2010-05-31
comments: true
tags: [  Best Practices, testing, Software Design ]
---

As I already highlighted in <a href="http://blog.js-development.com/2010/04/test-driven-design-real-world-scenario.html">several </a><a href="http://blog.js-development.com/2010/03/tackle-software-dependencies-with-ioc.html">previous </a>posts one of the most critical things when facing unit testing is an appropriate design. My sensation is that those rejecting unit tests...<br /><ul><li>do not care about code quality</li><li>are often poor programmers in terms of the code they produce (poor code design) and have therefore difficulties in writing automated tests for it</li><li>do not see the value behind them but still see them as just "more" work to do.</li></ul><div>Anyway, without going into details on this, I'd like to highlight the poor code design problem since that's probably one of the most prevalent reasons for people failing to write appropriate tests. Let's look at a "real-world" scenario <a href="http://blog.js-development.com/2010/04/test-driven-design-real-world-scenario.html">again</a>.<br /><br />Assume you really care about software architecture and design. You use interfaces for nicely decoupling the different system functionalities where the concrete object instances are being resolved at runtime by using factories. These factories access a configuration file (i.e. the web.config in ASP.net) for retrieving the type information and hosting DLL and then, through reflection, fetch the specific instance that has been configured for a given interface.<br />An entry in the config file could look like this:<br /><pre class="prettyprint">...<br />&lt;add requestedType="CompanyName.ProjectName.BusinessLogicInterface.INationBL, CompanyName.ProjectName.BusinessLogicInterface" fetcher="Singleton" paramType="CompanyName.ProjectName.BusinessLogic.NationBL, CompanyName.ProjectName.BusinessLogic"/&gt;<br />...<br /></pre>The according code using the factory then looks as follows<br /><pre class="prettyprint">...<br />INationBL nationBl = BLFactory.Instance.Get&lt;INationBL&gt;();<br />...</pre>According to the above mentioned configuration, your interface <code>INationBL</code> will be associated with an instance of type <code>NationBL</code>. I don't know whether you already got the advantage here: by having a configuration based factory and by only relying on interfaces, you externalize you dependencies from the code and you defer the resolving of the correct type to the moment of code execution.<br />This is good practice because by avoiding dependencies, you decouple which in turn will make life easier when writing automated tests against this logic.<br /><br /><b>Why is this?</b><br />Well, what we usually want when writing unit tests is to verify the correctness of a specific logic in isolation. So one of the things we do is to mock out&nbsp;undesirable object dependencies (like network resource access, DB access etc..). Assume the following <b>sample</b>&nbsp;code has to be tested. We want to verify whether it correctly returns the italian <code>Nation</code> object.<br /><pre class="prettyprint">...<br />public Nation GetItalianNation()<br />{<br />   Nation result = null;<br /><br />   INationBL nationBl = BLFactory.Instance.Get&lt;INationBL&gt;();<br />   List<nations> allNations = nationBl.ReadAllNations();<br />   if(allNations != null)<br />   {<br />      foreach (Nation nation in allNations)<br />      {<br />         if(nation.CountryCode == Nation.TypeOf.CountryCodeItaly)<br />         {<br />            result = nation;<br />            break;<br />         }<br />      }<br />   }<br /><br />   return result;<br />}   <br />...</nations></pre>To verify this, a possibility is to test the following scenarios<br /><ul><li><u>check for "null" result</u></li> <ul><li>allNations contains&nbsp;<i>no</i>&nbsp;objects at all</li><li>allNations contains multiple Nation objects, none of them however satisfying the condition of the nation.CountryCode.</li></ul><li><u>check for a valid italian Nation object:</u> <code>allNations</code> contains multiple entries, one of them being an italian Nation meaning the <code>nation.CountryCode</code> is equal to "300" (for example) which is represented by the constant <code><a href="http://blog.js-development.com/2010/01/comments-smell-replace-them-with-more.html">Nation.TypeOf.CountryCodeItaly</a></code>.</li></ul>To realize our testing strategy we have to assure that allNations get's properly filled. As you see, the code piece above fetches an instance of a <code>INationBL</code> object on which the <code>ReadAllNations()</code> method is invoked for retrieving the list of nations (from the DB). This is where our logic has to take place. Now given that we have our nice decoupling through our config-based factories we can place our own <i>MockNationBl</i>&nbsp;class.<br /><pre class="prettyprint">public class MockNationBl : INationBL<br />{<br /> //these are used to modify the nations collection<br /> private IList&lt;Nation&gt; _Nations;<br /> public IList&lt;Nation&gt; Nations<br /> {<br />  get<br />  {<br />   return _Nations;<br />  }<br />  set<br />  {<br />   _Nations = value;<br />  }<br /> }<br />...<br /> public IList&lt;Nation&gt; ReadAllNations()<br /> {<br />  return _Nations;<br /> }<br />...<br />}</pre>Now this generic mock let's us pretty easy do the testing job. Inside our testing project (you should have a different project for your tests!!) we create the factory mappings in the config file but instead of returning an instance of <code>NationBL</code> we return an instance of our <code>MockNationBl</code>.<br /><pre class="prettyprint">...<br />&lt;add requestedType="CompanyName.ProjectName.BusinessLogicInterface.INationBL, CompanyName.ProjectName.BusinessLogicInterface" fetcher="Singleton" paramType="CompanyName.ProjectName.BusinessLogic.MockNationBl, CompanyName.ProjectName.UnitTests"/&gt;<br />...<br /></pre>Something like the above. For those who still don't see the benefit of using interfaces...well this is it. You can easily switch the concrete object instances (see <a href="http://en.wikipedia.org/wiki/Strategy_pattern">strategy pattern</a> which exploits this concept). When launching the unit test and calling the <code>GetItalianNation()</code> method an instance of the <code>MockNationBl</code> will be used.<br /><br /><b>So what about the title. These factories should be a good thing, shouldn't they? Why "testability killer"?</b><br />Well "testability killer" is quite provocant actually :) . What I don't like about the above mentioned strategy is the overhead these factories create during testing. Config files are good for "outsourcing" configuration to a central place. This is what they are good for, but still, people tend to <i>forget</i> them or how to <i>correctly</i>&nbsp;set them. Moreover they limit your&nbsp;possibilities: what about if another developer needs his <code>INationBL</code> to be instantiated with another mock, not yours?? He just cannot.<br /><br />So what I'd like to have is an environment where concrete object instances are being retrieved from configuration files if you run your system, but still give you enough flexibility to inject your own ones during testing. May sound complex but it actually isn't. This is how DI frameworks basically work. To adapt the code above we don't have to change much, but just delegate the fetching of the concrete type to a class property as follows:<br /><pre class="prettyprint">public class SomeClass<br />{<br /><br /> private INationBL _NationBl;<br /> public INationBL NationBl<br /> {<br />  get<br />  {<br />   if(_NationBl == null)<br />    _NationBl = BLFactory.Instance.Get&lt;INationBL&gt;();<br />   return _NationBl;<br />  }<br />  set<br />  {<br />   _NationBl = value;<br />  }<br /> }<br /><br /> public Nation GetItalianNation()<br /> {<br />  Nation result = null;<br />  List allNations = _NationBl.ReadAllNations();<br />  if(allNations != null)<br />  {<br />   foreach (Nation nation in allNations)<br />   {<br />    ...<br />         }<br />  }<br /><br />  return result;<br /> }<br />}</pre>With this little modification the code gets much cleaner, the instance of an INationBL (if used multiple times) gets fetched/reused from a single place within the class, by default using the factory. In a possible test setup we can however easily create our mock implementation and "inject" it:<br /><pre class="prettyprint">...<br />[TestInitialize()]<br />public void SetUp()<br />{<br />   INationBL mockNationBL = new MockNationBL();<br />   someClass.NationBL = mockNationBl;<br />   ...<br />}<br />...<br /></pre></div><div>In this way you don't even need a configuration file in your test project. <a href="http://blog.js-development.com/2010/03/tackle-software-dependencies-with-ioc.html">DI frameworks</a> work similar, what I like about them is that they work according to the "hollywood principle". The impact on your written code is very small.</div>